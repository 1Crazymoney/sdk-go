// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/orders/v1beta1/orders.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Address of the oracle for the derivative contract
	Oracle string `protobuf:"bytes,2,opt,name=oracle,proto3" json:"oracle,omitempty"`
	// Address of the base currency for the derivative contract
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// Random number to faciltate uniqueness of the derivative market ID
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,7,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// price factor
	PriceFactor string `protobuf:"bytes,8,opt,name=price_factor,json=priceFactor,proto3" json:"price_factor,omitempty"`
	// index price
	IndexPrice string `protobuf:"bytes,9,opt,name=index_price,json=indexPrice,proto3" json:"index_price,omitempty"`
	// initial margin ratio
	InitialMarginRatio string `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3" json:"initial_margin_ratio,omitempty"`
	// maintenance margin ratio
	MaintenanceMarginRatio string `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3" json:"maintenance_margin_ratio,omitempty"`
}

func (m *DerivativeMarket) Reset()         { *m = DerivativeMarket{} }
func (m *DerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarket) ProtoMessage()    {}
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{0}
}
func (m *DerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarket.Merge(m, src)
}
func (m *DerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarket proto.InternalMessageInfo

func (m *DerivativeMarket) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *DerivativeMarket) GetOracle() string {
	if m != nil {
		return m.Oracle
	}
	return ""
}

func (m *DerivativeMarket) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *DerivativeMarket) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *DerivativeMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeMarket) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DerivativeMarket) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *DerivativeMarket) GetPriceFactor() string {
	if m != nil {
		return m.PriceFactor
	}
	return ""
}

func (m *DerivativeMarket) GetIndexPrice() string {
	if m != nil {
		return m.IndexPrice
	}
	return ""
}

func (m *DerivativeMarket) GetInitialMarginRatio() string {
	if m != nil {
		return m.InitialMarginRatio
	}
	return ""
}

func (m *DerivativeMarket) GetMaintenanceMarginRatio() string {
	if m != nil {
		return m.MaintenanceMarginRatio
	}
	return ""
}

// An object describing trade pair of two assets.
type TradePair struct {
	// A name of the pair in format AAA/BBB, where AAA - maker's asset, BBB -
	// taker's asset.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,2,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,3,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// Hash of both asset data, to identify the trading pair in store.
	Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *TradePair) Reset()         { *m = TradePair{} }
func (m *TradePair) String() string { return proto.CompactTextString(m) }
func (*TradePair) ProtoMessage()    {}
func (*TradePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{1}
}
func (m *TradePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradePair.Merge(m, src)
}
func (m *TradePair) XXX_Size() int {
	return m.Size()
}
func (m *TradePair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradePair.DiscardUnknown(m)
}

var xxx_messageInfo_TradePair proto.InternalMessageInfo

func (m *TradePair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TradePair) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *TradePair) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *TradePair) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TradePair) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// A valid signed 0x order based on the schema.
type BaseOrder struct {
	// Specify chain ID.
	ChainId int64 `protobuf:"zigzag64,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress string `protobuf:"bytes,2,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// Address that created the order.
	MakerAddress string `protobuf:"bytes,3,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `protobuf:"bytes,4,opt,name=taker_address,json=takerAddress,proto3" json:"taker_address,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `protobuf:"bytes,5,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `protobuf:"bytes,6,opt,name=sender_address,json=senderAddress,proto3" json:"sender_address,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `protobuf:"bytes,7,opt,name=maker_asset_amount,json=makerAssetAmount,proto3" json:"maker_asset_amount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `protobuf:"bytes,8,opt,name=taker_asset_amount,json=takerAssetAmount,proto3" json:"taker_asset_amount,omitempty"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `protobuf:"bytes,9,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `protobuf:"bytes,10,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `protobuf:"bytes,11,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `protobuf:"bytes,12,opt,name=salt,proto3" json:"salt,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,13,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,14,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `protobuf:"bytes,15,opt,name=maker_fee_asset_data,json=makerFeeAssetData,proto3" json:"maker_fee_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `protobuf:"bytes,16,opt,name=taker_fee_asset_data,json=takerFeeAssetData,proto3" json:"taker_fee_asset_data,omitempty"`
	// Order signature.
	Signature string `protobuf:"bytes,17,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BaseOrder) Reset()         { *m = BaseOrder{} }
func (m *BaseOrder) String() string { return proto.CompactTextString(m) }
func (*BaseOrder) ProtoMessage()    {}
func (*BaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{2}
}
func (m *BaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseOrder.Merge(m, src)
}
func (m *BaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *BaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BaseOrder proto.InternalMessageInfo

func (m *BaseOrder) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BaseOrder) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *BaseOrder) GetTakerAddress() string {
	if m != nil {
		return m.TakerAddress
	}
	return ""
}

func (m *BaseOrder) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *BaseOrder) GetSenderAddress() string {
	if m != nil {
		return m.SenderAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetAmount() string {
	if m != nil {
		return m.MakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetAmount() string {
	if m != nil {
		return m.TakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetMakerFee() string {
	if m != nil {
		return m.MakerFee
	}
	return ""
}

func (m *BaseOrder) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *BaseOrder) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *BaseOrder) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetMakerFeeAssetData() string {
	if m != nil {
		return m.MakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerFeeAssetData() string {
	if m != nil {
		return m.TakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// A valid signed 0x order with Metadata.
type Order struct {
	Order                 *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	TradePairHash         string     `protobuf:"bytes,2,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
	FilledAmount          string     `protobuf:"bytes,3,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	Status                int64      `protobuf:"zigzag64,4,opt,name=status,proto3" json:"status,omitempty"`
	IndexPriceRequirement string     `protobuf:"bytes,5,opt,name=index_price_requirement,json=indexPriceRequirement,proto3" json:"index_price_requirement,omitempty"`
	SubaccountID          string     `protobuf:"bytes,6,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{3}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Order) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

func (m *Order) GetFilledAmount() string {
	if m != nil {
		return m.FilledAmount
	}
	return ""
}

func (m *Order) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Order) GetIndexPriceRequirement() string {
	if m != nil {
		return m.IndexPriceRequirement
	}
	return ""
}

func (m *Order) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// An order quote with fillable data
type OrderQuote struct {
	Order          *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	FillableAmount string     `protobuf:"bytes,2,opt,name=fillable_amount,json=fillableAmount,proto3" json:"fillable_amount,omitempty"`
}

func (m *OrderQuote) Reset()         { *m = OrderQuote{} }
func (m *OrderQuote) String() string { return proto.CompactTextString(m) }
func (*OrderQuote) ProtoMessage()    {}
func (*OrderQuote) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{4}
}
func (m *OrderQuote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderQuote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderQuote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderQuote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderQuote.Merge(m, src)
}
func (m *OrderQuote) XXX_Size() int {
	return m.Size()
}
func (m *OrderQuote) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderQuote.DiscardUnknown(m)
}

var xxx_messageInfo_OrderQuote proto.InternalMessageInfo

func (m *OrderQuote) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *OrderQuote) GetFillableAmount() string {
	if m != nil {
		return m.FillableAmount
	}
	return ""
}

// An orderbook price level
type PriceLevel struct {
	// price
	P string `protobuf:"bytes,1,opt,name=p,proto3" json:"p,omitempty"`
	// quantity
	Q string `protobuf:"bytes,2,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *PriceLevel) Reset()         { *m = PriceLevel{} }
func (m *PriceLevel) String() string { return proto.CompactTextString(m) }
func (*PriceLevel) ProtoMessage()    {}
func (*PriceLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{5}
}
func (m *PriceLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceLevel.Merge(m, src)
}
func (m *PriceLevel) XXX_Size() int {
	return m.Size()
}
func (m *PriceLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceLevel.DiscardUnknown(m)
}

var xxx_messageInfo_PriceLevel proto.InternalMessageInfo

func (m *PriceLevel) GetP() string {
	if m != nil {
		return m.P
	}
	return ""
}

func (m *PriceLevel) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

// A valid signed 0x Signed Transaction
type SignedTransaction struct {
	// Arbitrary number to facilitate uniqueness of the transactions's hash.
	Salt string `protobuf:"bytes,1,opt,name=salt,proto3" json:"salt,omitempty"`
	// Address of transaction signer
	SignerAddress string `protobuf:"bytes,2,opt,name=signer_address,json=signerAddress,proto3" json:"signer_address,omitempty"`
	// The calldata that is to be executed. This must call an Exchange contract
	// method.
	Data string `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// Timestamp in seconds at which transaction expires.
	ExpirationTimeSeconds string `protobuf:"bytes,4,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// gasPrice that transaction is required to be executed with.
	GasPrice string `protobuf:"bytes,5,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Exchange Domain specific values.
	Domain *ExchangeDomain `protobuf:"bytes,6,opt,name=domain,proto3" json:"domain,omitempty"`
	// Signature of the 0x Transaction
	Signature string `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedTransaction) Reset()         { *m = SignedTransaction{} }
func (m *SignedTransaction) String() string { return proto.CompactTextString(m) }
func (*SignedTransaction) ProtoMessage()    {}
func (*SignedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{6}
}
func (m *SignedTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransaction.Merge(m, src)
}
func (m *SignedTransaction) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransaction proto.InternalMessageInfo

func (m *SignedTransaction) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *SignedTransaction) GetSignerAddress() string {
	if m != nil {
		return m.SignerAddress
	}
	return ""
}

func (m *SignedTransaction) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *SignedTransaction) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *SignedTransaction) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *SignedTransaction) GetDomain() *ExchangeDomain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *SignedTransaction) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// A 0x Transaction Exchange Domain
type ExchangeDomain struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract string `protobuf:"bytes,1,opt,name=verifying_contract,json=verifyingContract,proto3" json:"verifying_contract,omitempty"`
	// Ethereum Chain ID of the transaction
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ExchangeDomain) Reset()         { *m = ExchangeDomain{} }
func (m *ExchangeDomain) String() string { return proto.CompactTextString(m) }
func (*ExchangeDomain) ProtoMessage()    {}
func (*ExchangeDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{7}
}
func (m *ExchangeDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDomain.Merge(m, src)
}
func (m *ExchangeDomain) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDomain.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDomain proto.InternalMessageInfo

func (m *ExchangeDomain) GetVerifyingContract() string {
	if m != nil {
		return m.VerifyingContract
	}
	return ""
}

func (m *ExchangeDomain) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// A 0x Coordinator Transaction Fill Signatures
type FillSignatures struct {
	// EIP712 hash of order (see LibOrder.getTypedDataHash)
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// Array of signatures that correspond to the required signatures to execute
	// each order in the transaction
	ApprovalSignatures []string `protobuf:"bytes,2,rep,name=approval_signatures,json=approvalSignatures,proto3" json:"approval_signatures,omitempty"`
	// Timestamp in seconds at which approval expires
	ExpirationTimeSeconds string `protobuf:"bytes,3,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Desired amount of takerAsset to sell
	TakerAssetFillAmount string `protobuf:"bytes,4,opt,name=taker_asset_fill_amount,json=takerAssetFillAmount,proto3" json:"taker_asset_fill_amount,omitempty"`
}

func (m *FillSignatures) Reset()         { *m = FillSignatures{} }
func (m *FillSignatures) String() string { return proto.CompactTextString(m) }
func (*FillSignatures) ProtoMessage()    {}
func (*FillSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{8}
}
func (m *FillSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FillSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FillSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FillSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FillSignatures.Merge(m, src)
}
func (m *FillSignatures) XXX_Size() int {
	return m.Size()
}
func (m *FillSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_FillSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_FillSignatures proto.InternalMessageInfo

func (m *FillSignatures) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *FillSignatures) GetApprovalSignatures() []string {
	if m != nil {
		return m.ApprovalSignatures
	}
	return nil
}

func (m *FillSignatures) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *FillSignatures) GetTakerAssetFillAmount() string {
	if m != nil {
		return m.TakerAssetFillAmount
	}
	return ""
}

// A 0x Transaction Exchange Domain
type ZeroExTransaction struct {
	ZeroExTransactionType int64    `protobuf:"zigzag64,1,opt,name=zero_ex_transaction_type,json=zeroExTransactionType,proto3" json:"zero_ex_transaction_type,omitempty"`
	Orders                []string `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
}

func (m *ZeroExTransaction) Reset()         { *m = ZeroExTransaction{} }
func (m *ZeroExTransaction) String() string { return proto.CompactTextString(m) }
func (*ZeroExTransaction) ProtoMessage()    {}
func (*ZeroExTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{9}
}
func (m *ZeroExTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroExTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroExTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroExTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroExTransaction.Merge(m, src)
}
func (m *ZeroExTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ZeroExTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroExTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroExTransaction proto.InternalMessageInfo

func (m *ZeroExTransaction) GetZeroExTransactionType() int64 {
	if m != nil {
		return m.ZeroExTransactionType
	}
	return 0
}

func (m *ZeroExTransaction) GetOrders() []string {
	if m != nil {
		return m.Orders
	}
	return nil
}

// A 0x Transaction Exchange Domain
type MsgCreateSpotOrder struct {
	Sender string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgCreateSpotOrder) Reset()         { *m = MsgCreateSpotOrder{} }
func (m *MsgCreateSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotOrder) ProtoMessage()    {}
func (*MsgCreateSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{10}
}
func (m *MsgCreateSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotOrder.Merge(m, src)
}
func (m *MsgCreateSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeOrder
type MsgCreateDerivativeOrder struct {
	Sender string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgCreateDerivativeOrder) Reset()         { *m = MsgCreateDerivativeOrder{} }
func (m *MsgCreateDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{11}
}
func (m *MsgCreateDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgRequestFillSpotOrder
type MsgRequestFillSpotOrder struct {
	Sender            string             `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SignedTransaction *SignedTransaction `protobuf:"bytes,2,opt,name=signed_transaction,json=signedTransaction,proto3" json:"signed_transaction,omitempty"`
	TxOrigin          string             `protobuf:"bytes,3,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	ApprovalSignature string             `protobuf:"bytes,4,opt,name=approval_signature,json=approvalSignature,proto3" json:"approval_signature,omitempty"`
}

func (m *MsgRequestFillSpotOrder) Reset()         { *m = MsgRequestFillSpotOrder{} }
func (m *MsgRequestFillSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgRequestFillSpotOrder) ProtoMessage()    {}
func (*MsgRequestFillSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{12}
}
func (m *MsgRequestFillSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestFillSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestFillSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestFillSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestFillSpotOrder.Merge(m, src)
}
func (m *MsgRequestFillSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestFillSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestFillSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestFillSpotOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgRequestSoftCancelSpotOrder
type MsgRequestSoftCancelSpotOrder struct {
	Sender            string             `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SignedTransaction *SignedTransaction `protobuf:"bytes,2,opt,name=signed_transaction,json=signedTransaction,proto3" json:"signed_transaction,omitempty"`
	TxOrigin          string             `protobuf:"bytes,3,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	ApprovalSignature string             `protobuf:"bytes,4,opt,name=approval_signature,json=approvalSignature,proto3" json:"approval_signature,omitempty"`
}

func (m *MsgRequestSoftCancelSpotOrder) Reset()         { *m = MsgRequestSoftCancelSpotOrder{} }
func (m *MsgRequestSoftCancelSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgRequestSoftCancelSpotOrder) ProtoMessage()    {}
func (*MsgRequestSoftCancelSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{13}
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestSoftCancelSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestSoftCancelSpotOrder.Merge(m, src)
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestSoftCancelSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestSoftCancelSpotOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgRegisterSpotMarket
type MsgRegisterSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	Enabled        bool   `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MsgRegisterSpotMarket) Reset()         { *m = MsgRegisterSpotMarket{} }
func (m *MsgRegisterSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterSpotMarket) ProtoMessage()    {}
func (*MsgRegisterSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{14}
}
func (m *MsgRegisterSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterSpotMarket.Merge(m, src)
}
func (m *MsgRegisterSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgSuspendSpotMarket
type MsgSuspendSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgSuspendSpotMarket) Reset()         { *m = MsgSuspendSpotMarket{} }
func (m *MsgSuspendSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendSpotMarket) ProtoMessage()    {}
func (*MsgSuspendSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{15}
}
func (m *MsgSuspendSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendSpotMarket.Merge(m, src)
}
func (m *MsgSuspendSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgResumeSpotMarket
type MsgResumeSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgResumeSpotMarket) Reset()         { *m = MsgResumeSpotMarket{} }
func (m *MsgResumeSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeSpotMarket) ProtoMessage()    {}
func (*MsgResumeSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{16}
}
func (m *MsgResumeSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeSpotMarket.Merge(m, src)
}
func (m *MsgResumeSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgRegisterDerivativeMarket
type MsgRegisterDerivativeMarket struct {
	Sender string            `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Market *DerivativeMarket `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
}

func (m *MsgRegisterDerivativeMarket) Reset()         { *m = MsgRegisterDerivativeMarket{} }
func (m *MsgRegisterDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDerivativeMarket) ProtoMessage()    {}
func (*MsgRegisterDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{17}
}
func (m *MsgRegisterDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDerivativeMarket.Merge(m, src)
}
func (m *MsgRegisterDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDerivativeMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgSuspendDerivativeMarket
type MsgSuspendDerivativeMarket struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,3,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *MsgSuspendDerivativeMarket) Reset()         { *m = MsgSuspendDerivativeMarket{} }
func (m *MsgSuspendDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendDerivativeMarket) ProtoMessage()    {}
func (*MsgSuspendDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{18}
}
func (m *MsgSuspendDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendDerivativeMarket.Merge(m, src)
}
func (m *MsgSuspendDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendDerivativeMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgResumeDerivativeMarket
type MsgResumeDerivativeMarket struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,3,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *MsgResumeDerivativeMarket) Reset()         { *m = MsgResumeDerivativeMarket{} }
func (m *MsgResumeDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeDerivativeMarket) ProtoMessage()    {}
func (*MsgResumeDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{19}
}
func (m *MsgResumeDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeDerivativeMarket.Merge(m, src)
}
func (m *MsgResumeDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeDerivativeMarket proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DerivativeMarket)(nil), "injective.orders.v1beta1.DerivativeMarket")
	proto.RegisterType((*TradePair)(nil), "injective.orders.v1beta1.TradePair")
	proto.RegisterType((*BaseOrder)(nil), "injective.orders.v1beta1.BaseOrder")
	proto.RegisterType((*Order)(nil), "injective.orders.v1beta1.Order")
	proto.RegisterType((*OrderQuote)(nil), "injective.orders.v1beta1.OrderQuote")
	proto.RegisterType((*PriceLevel)(nil), "injective.orders.v1beta1.PriceLevel")
	proto.RegisterType((*SignedTransaction)(nil), "injective.orders.v1beta1.SignedTransaction")
	proto.RegisterType((*ExchangeDomain)(nil), "injective.orders.v1beta1.ExchangeDomain")
	proto.RegisterType((*FillSignatures)(nil), "injective.orders.v1beta1.FillSignatures")
	proto.RegisterType((*ZeroExTransaction)(nil), "injective.orders.v1beta1.ZeroExTransaction")
	proto.RegisterType((*MsgCreateSpotOrder)(nil), "injective.orders.v1beta1.MsgCreateSpotOrder")
	proto.RegisterType((*MsgCreateDerivativeOrder)(nil), "injective.orders.v1beta1.MsgCreateDerivativeOrder")
	proto.RegisterType((*MsgRequestFillSpotOrder)(nil), "injective.orders.v1beta1.MsgRequestFillSpotOrder")
	proto.RegisterType((*MsgRequestSoftCancelSpotOrder)(nil), "injective.orders.v1beta1.MsgRequestSoftCancelSpotOrder")
	proto.RegisterType((*MsgRegisterSpotMarket)(nil), "injective.orders.v1beta1.MsgRegisterSpotMarket")
	proto.RegisterType((*MsgSuspendSpotMarket)(nil), "injective.orders.v1beta1.MsgSuspendSpotMarket")
	proto.RegisterType((*MsgResumeSpotMarket)(nil), "injective.orders.v1beta1.MsgResumeSpotMarket")
	proto.RegisterType((*MsgRegisterDerivativeMarket)(nil), "injective.orders.v1beta1.MsgRegisterDerivativeMarket")
	proto.RegisterType((*MsgSuspendDerivativeMarket)(nil), "injective.orders.v1beta1.MsgSuspendDerivativeMarket")
	proto.RegisterType((*MsgResumeDerivativeMarket)(nil), "injective.orders.v1beta1.MsgResumeDerivativeMarket")
}

func init() {
	proto.RegisterFile("injective/orders/v1beta1/orders.proto", fileDescriptor_cf94b0bf3cc7fbf1)
}

var fileDescriptor_cf94b0bf3cc7fbf1 = []byte{
	// 1370 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4b, 0x6f, 0x1b, 0xd5,
	0x17, 0xcf, 0xe4, 0x69, 0x9f, 0xc4, 0x4e, 0x7c, 0x9b, 0xb4, 0xd3, 0xf6, 0xdf, 0xb4, 0x7f, 0x87,
	0x42, 0x78, 0x34, 0xa6, 0x45, 0x3c, 0x57, 0xb4, 0x49, 0x2b, 0x22, 0x35, 0x6a, 0x71, 0xb2, 0xca,
	0x66, 0x74, 0x3d, 0x73, 0x3c, 0xb9, 0xd4, 0xbe, 0x33, 0xbd, 0xf7, 0x3a, 0x72, 0xba, 0x41, 0x20,
	0x21, 0xb1, 0x83, 0x1d, 0x0b, 0x58, 0xc0, 0x9e, 0x3d, 0x5f, 0x81, 0x1d, 0x5d, 0xb2, 0x03, 0xb5,
	0xe2, 0x7b, 0xa0, 0xfb, 0x18, 0xcf, 0xd8, 0x71, 0xd2, 0x22, 0x84, 0xa8, 0xd8, 0xcd, 0x39, 0xe7,
	0x77, 0xc6, 0xe7, 0xf1, 0x3b, 0xe7, 0xde, 0x31, 0x5c, 0x65, 0xfc, 0x13, 0x0c, 0x15, 0x3b, 0xc4,
	0x46, 0x22, 0x22, 0x14, 0xb2, 0x71, 0x78, 0xbd, 0x85, 0x8a, 0x5e, 0x77, 0xe2, 0x46, 0x2a, 0x12,
	0x95, 0x10, 0x7f, 0x00, 0xdb, 0x70, 0x7a, 0x07, 0xbb, 0xb0, 0x1c, 0x27, 0x71, 0x62, 0x40, 0x0d,
	0xfd, 0x64, 0xf1, 0xf5, 0xaf, 0xa6, 0x60, 0x69, 0x0b, 0x05, 0x3b, 0xa4, 0xda, 0x67, 0x87, 0x8a,
	0x07, 0xa8, 0xc8, 0x59, 0x98, 0x55, 0x2c, 0x7c, 0x80, 0xc2, 0xf7, 0xae, 0x78, 0xeb, 0xe5, 0xa6,
	0x93, 0xb4, 0x3e, 0x11, 0x34, 0xec, 0xa0, 0x3f, 0x69, 0xf5, 0x56, 0x22, 0x6b, 0x50, 0x69, 0x51,
	0x89, 0x41, 0xd8, 0x13, 0x02, 0x79, 0x78, 0xe4, 0x4f, 0x19, 0xf3, 0x82, 0x56, 0x6e, 0x3a, 0x1d,
	0x59, 0x86, 0x19, 0x9e, 0xf0, 0x10, 0xfd, 0x69, 0x63, 0xb4, 0x02, 0xb9, 0x08, 0xe5, 0xae, 0xf9,
	0xd1, 0x80, 0x45, 0xfe, 0x8c, 0xb1, 0x94, 0xac, 0x62, 0x3b, 0x22, 0x3e, 0xcc, 0x21, 0xa7, 0xad,
	0x0e, 0x46, 0xfe, 0xec, 0x15, 0x6f, 0xbd, 0xd4, 0xcc, 0x44, 0xf2, 0x2a, 0x2c, 0x61, 0x3f, 0x3c,
	0xa0, 0x3c, 0xc6, 0x80, 0x46, 0x91, 0x40, 0x29, 0xfd, 0x39, 0xe3, 0xbd, 0x98, 0xe9, 0x6f, 0x5a,
	0x35, 0xf9, 0x3f, 0x2c, 0xa4, 0x82, 0x85, 0x18, 0xb4, 0x69, 0xa8, 0x12, 0xe1, 0x97, 0x0c, 0x6c,
	0xde, 0xe8, 0xee, 0x18, 0x15, 0xb9, 0x0c, 0xf3, 0x8c, 0x47, 0xd8, 0x0f, 0x8c, 0xd2, 0x2f, 0x1b,
	0x04, 0x18, 0xd5, 0x7d, 0xad, 0x21, 0x6f, 0xc2, 0x32, 0xe3, 0x4c, 0x31, 0xda, 0x09, 0xba, 0x54,
	0xc4, 0x8c, 0x07, 0x82, 0x2a, 0x96, 0xf8, 0x60, 0x90, 0xc4, 0xd9, 0x76, 0x8c, 0xa9, 0xa9, 0x2d,
	0xe4, 0x3d, 0xf0, 0xbb, 0x94, 0x71, 0x85, 0x9c, 0xf2, 0x10, 0x87, 0xbd, 0xe6, 0x8d, 0xd7, 0xd9,
	0x82, 0xbd, 0xe0, 0x59, 0xff, 0xc1, 0x83, 0xf2, 0x9e, 0xa0, 0x11, 0xde, 0xa7, 0x4c, 0x10, 0x02,
	0xd3, 0x9c, 0x76, 0xd1, 0x35, 0xc2, 0x3c, 0x93, 0x75, 0x58, 0xea, 0xd2, 0x07, 0x28, 0x02, 0x2a,
	0x25, 0xaa, 0x20, 0xa2, 0x8a, 0xba, 0x86, 0x54, 0x8d, 0xfe, 0xa6, 0x56, 0x6f, 0x51, 0x45, 0x35,
	0x52, 0x8d, 0x22, 0x6d, 0x6f, 0xaa, 0x6a, 0x18, 0x49, 0x60, 0xfa, 0x80, 0xca, 0x03, 0xd7, 0x1c,
	0xf3, 0x5c, 0x2c, 0xff, 0xcc, 0x50, 0xf9, 0xeb, 0x3f, 0xce, 0x40, 0xf9, 0x16, 0x95, 0x78, 0x4f,
	0x53, 0x8c, 0x9c, 0x87, 0x52, 0x78, 0x40, 0x19, 0xd7, 0x2d, 0xd4, 0x71, 0x92, 0xe6, 0x9c, 0x91,
	0xb7, 0xc7, 0xf7, 0x69, 0x72, 0x7c, 0x9f, 0xd6, 0xa0, 0xe2, 0xb2, 0x72, 0x38, 0x47, 0x22, 0x9b,
	0x52, 0x0e, 0x52, 0x43, 0x20, 0x1b, 0xef, 0x82, 0x2a, 0x82, 0x6e, 0xc0, 0x4a, 0x1b, 0x31, 0x10,
	0x18, 0xb2, 0x94, 0x21, 0x57, 0x03, 0xb0, 0xe5, 0xd7, 0x99, 0x36, 0x62, 0x33, 0xb3, 0x65, 0x3e,
	0x57, 0xa1, 0x2a, 0x91, 0x47, 0x85, 0x37, 0xcf, 0x1a, 0x70, 0xc5, 0x6a, 0x33, 0xd8, 0x1b, 0x40,
	0x8a, 0xa5, 0xa7, 0xdd, 0xa4, 0xc7, 0x95, 0x63, 0xde, 0x52, 0x5e, 0xfc, 0x9b, 0x46, 0xaf, 0xd1,
	0xea, 0x38, 0xda, 0x12, 0x70, 0x49, 0x8d, 0xa2, 0xcd, 0x28, 0x68, 0x74, 0x1b, 0x33, 0x0e, 0x96,
	0x8c, 0xe2, 0x0e, 0x9a, 0x39, 0x51, 0x03, 0xa3, 0xa5, 0x5d, 0x49, 0x65, 0xc6, 0x77, 0xe0, 0x1c,
	0xf6, 0x53, 0x66, 0xd8, 0xc5, 0x03, 0xc5, 0xba, 0x18, 0x48, 0x0c, 0x13, 0x1e, 0x49, 0xc7, 0xb5,
	0x95, 0xdc, 0xbc, 0xc7, 0xba, 0xb8, 0x6b, 0x8d, 0xba, 0xe9, 0x92, 0x76, 0x94, 0xbf, 0x60, 0x9b,
	0xae, 0x9f, 0xc7, 0x92, 0xab, 0xf2, 0xdc, 0xe4, 0xaa, 0x8e, 0x25, 0x57, 0x03, 0x96, 0x07, 0x99,
	0x15, 0xd1, 0x8b, 0x06, 0x5d, 0xcb, 0x92, 0x1c, 0x72, 0x50, 0xe3, 0x1c, 0x96, 0xac, 0x83, 0x3a,
	0xe6, 0xf0, 0x3f, 0x28, 0x4b, 0x16, 0x73, 0xaa, 0x7a, 0x02, 0xfd, 0x9a, 0x41, 0xe5, 0x8a, 0xfa,
	0x17, 0x93, 0x30, 0x63, 0xa9, 0xfa, 0x3e, 0xcc, 0x98, 0xb5, 0x68, 0x78, 0x3a, 0x7f, 0x63, 0x6d,
	0xe3, 0xa4, 0x75, 0xb9, 0x31, 0xa0, 0x77, 0xd3, 0x7a, 0x90, 0x97, 0x61, 0x51, 0xe9, 0xb1, 0x0c,
	0x52, 0xca, 0x44, 0x60, 0x86, 0xc5, 0x32, 0xb9, 0xa2, 0xb2, 0x69, 0xfd, 0x48, 0x4f, 0xcd, 0x1a,
	0x54, 0xda, 0xac, 0xd3, 0xc1, 0x28, 0xeb, 0xb7, 0xe3, 0xb1, 0x55, 0xba, 0x5e, 0x9f, 0x85, 0x59,
	0xa9, 0xa8, 0xea, 0x59, 0x02, 0x93, 0xa6, 0x93, 0x74, 0x27, 0x0b, 0x9b, 0x28, 0x10, 0xf8, 0xb0,
	0xc7, 0x04, 0x76, 0x91, 0x2b, 0x47, 0xde, 0x95, 0x7c, 0x2b, 0x35, 0x73, 0x23, 0x79, 0x09, 0xaa,
	0xb2, 0xd7, 0xa2, 0x61, 0xa8, 0xdf, 0x1e, 0xb0, 0x20, 0x72, 0xf4, 0x5d, 0xc8, 0xb5, 0xdb, 0x5b,
	0xf5, 0x14, 0xc0, 0xa4, 0xf4, 0x71, 0x2f, 0x51, 0xf8, 0x77, 0x6a, 0xf1, 0x0a, 0x2c, 0xea, 0x74,
	0xf4, 0x32, 0xc8, 0xb2, 0x74, 0x0b, 0x28, 0x53, 0xdb, 0x3c, 0xeb, 0xeb, 0x00, 0x26, 0xd6, 0xbb,
	0x78, 0x88, 0x1d, 0xb2, 0x00, 0x5e, 0xea, 0x36, 0x99, 0x97, 0x6a, 0xe9, 0xa1, 0x73, 0xf3, 0x1e,
	0xd6, 0xbf, 0x99, 0x84, 0xda, 0x2e, 0x8b, 0x39, 0x46, 0x7b, 0x82, 0x72, 0x49, 0x43, 0x4d, 0xd6,
	0x01, 0x43, 0xbd, 0x02, 0x43, 0xf5, 0xa8, 0x6a, 0xa0, 0x18, 0xd9, 0x28, 0x15, 0xab, 0xcd, 0x46,
	0x95, 0xc0, 0x74, 0x61, 0xdf, 0x99, 0xe7, 0xd3, 0x06, 0x65, 0xfa, 0xb4, 0x41, 0xb9, 0x08, 0xe5,
	0x98, 0x4a, 0x77, 0x3c, 0xb8, 0x53, 0x2a, 0xa6, 0xd2, 0x1e, 0x0e, 0x1f, 0xc2, 0x6c, 0x94, 0xe8,
	0x65, 0x6e, 0x6a, 0x3e, 0x7f, 0x63, 0xfd, 0xe4, 0x42, 0xde, 0x76, 0x3b, 0x6f, 0xcb, 0xe0, 0x9b,
	0xce, 0x6f, 0x98, 0xbd, 0x73, 0xa3, 0xec, 0xdd, 0x87, 0xea, 0xb0, 0x1f, 0xb9, 0x06, 0xe4, 0x10,
	0x05, 0x6b, 0x1f, 0x31, 0x1e, 0x07, 0x61, 0xc2, 0x95, 0xa0, 0x61, 0x56, 0xa3, 0xda, 0xc0, 0xb2,
	0xe9, 0x0c, 0x43, 0xfb, 0xd9, 0x96, 0x2a, 0xdb, 0xcf, 0xf5, 0x5f, 0x3c, 0xa8, 0xde, 0x61, 0x9d,
	0xce, 0x6e, 0xf6, 0x6b, 0x92, 0x5c, 0x02, 0x30, 0x51, 0x5b, 0x8a, 0xdb, 0x97, 0x96, 0x8d, 0xc6,
	0xd0, 0xbb, 0x01, 0x67, 0x68, 0x9a, 0x8a, 0xe4, 0x90, 0x76, 0x82, 0x41, 0x8c, 0xba, 0x05, 0x53,
	0xfa, 0x24, 0xcc, 0x4c, 0x85, 0xf7, 0x9d, 0x52, 0xf3, 0xa9, 0xd3, 0x6a, 0xfe, 0x36, 0x9c, 0x2b,
	0xae, 0x17, 0x4d, 0xac, 0x8c, 0x6b, 0xb6, 0x57, 0xcb, 0xf9, 0x96, 0xd1, 0x29, 0x38, 0xc6, 0x45,
	0x50, 0xdb, 0x47, 0x91, 0xdc, 0xee, 0x17, 0x69, 0xf4, 0x2e, 0xf8, 0x8f, 0x50, 0x24, 0x01, 0xf6,
	0x03, 0x95, 0xab, 0x03, 0x75, 0x94, 0xa2, 0x3b, 0xb1, 0x56, 0x1e, 0x8d, 0x3a, 0xed, 0x1d, 0xa5,
	0x68, 0x6f, 0x3c, 0xba, 0x85, 0x2e, 0x41, 0x27, 0xd5, 0xbb, 0x40, 0x76, 0x64, 0xbc, 0x29, 0x90,
	0x2a, 0xdc, 0x4d, 0x13, 0x65, 0xb7, 0x8b, 0x9e, 0x6a, 0x73, 0x5c, 0x64, 0xf7, 0x26, 0x2b, 0xe5,
	0x93, 0x36, 0xf9, 0x57, 0x27, 0xed, 0x83, 0xe9, 0x2f, 0xbf, 0xbf, 0x3c, 0x51, 0x97, 0xe0, 0x0f,
	0x7e, 0x2e, 0xbf, 0xad, 0xfd, 0xc3, 0x3f, 0xfa, 0x9b, 0x07, 0xe7, 0x76, 0x64, 0xac, 0xd7, 0x0c,
	0x4a, 0x53, 0xe2, 0x67, 0x67, 0xba, 0x0f, 0xc4, 0x4c, 0x61, 0x54, 0xac, 0xb3, 0x8b, 0xe0, 0xf5,
	0x93, 0x23, 0x38, 0x36, 0xf8, 0xcd, 0x9a, 0x3c, 0xb6, 0x0b, 0xf4, 0x11, 0xd8, 0x0f, 0x12, 0xc1,
	0x62, 0xc6, 0x1d, 0x75, 0x4a, 0xaa, 0x7f, 0xcf, 0xc8, 0x7a, 0x24, 0x8e, 0xd3, 0xd2, 0x11, 0xa5,
	0x76, 0x8c, 0x95, 0x2e, 0xc3, 0x3f, 0x3c, 0xb8, 0x94, 0x67, 0xb8, 0x9b, 0xb4, 0xd5, 0xa6, 0xbe,
	0x8d, 0xfd, 0xe7, 0xf2, 0xfc, 0xc9, 0x83, 0x15, 0x93, 0x67, 0xcc, 0xa4, 0x42, 0xa1, 0xd3, 0xcb,
	0x6f, 0xfa, 0x63, 0xf3, 0xcb, 0xae, 0x9d, 0x93, 0xcf, 0xb8, 0x76, 0x4e, 0x3d, 0xf7, 0xcd, 0x60,
	0x7a, 0xec, 0xcd, 0xe0, 0xc4, 0x2b, 0xa6, 0x8b, 0xfc, 0x3b, 0x0f, 0x96, 0x77, 0x64, 0xbc, 0xdb,
	0x93, 0x29, 0xf2, 0xe8, 0xc5, 0x09, 0xdc, 0x85, 0xf7, 0xad, 0x07, 0x67, 0x4c, 0x61, 0x65, 0xaf,
	0x8b, 0x2f, 0x5c, 0x74, 0x9f, 0xc2, 0xc5, 0x42, 0xd7, 0xc7, 0x7d, 0xe5, 0x8d, 0x0d, 0xf2, 0x16,
	0xcc, 0xda, 0x2f, 0x30, 0xc7, 0xe7, 0xd7, 0x4e, 0xe6, 0xf3, 0xe8, 0x3b, 0x9b, 0xce, 0xd3, 0x05,
	0xf0, 0xb9, 0x07, 0x17, 0xf2, 0xee, 0x3d, 0x77, 0x00, 0x43, 0xdf, 0x84, 0x93, 0x23, 0xdf, 0x84,
	0xe3, 0xbe, 0x28, 0xa6, 0xc6, 0x7e, 0x51, 0xb8, 0x20, 0x3e, 0xf3, 0xe0, 0xfc, 0xa0, 0x47, 0xff,
	0x4e, 0x0c, 0xb7, 0xda, 0x3f, 0x3f, 0x59, 0xf5, 0x1e, 0x3f, 0x59, 0xf5, 0x7e, 0x7f, 0xb2, 0xea,
	0x7d, 0xfd, 0x74, 0x75, 0xe2, 0xf1, 0xd3, 0xd5, 0x89, 0x5f, 0x9f, 0xae, 0x4e, 0xec, 0xdf, 0x8d,
	0x99, 0x3a, 0xe8, 0xb5, 0x36, 0xc2, 0xa4, 0xdb, 0xd8, 0xce, 0xca, 0x7c, 0x97, 0xb6, 0x64, 0x63,
	0x50, 0xf4, 0x6b, 0x61, 0x22, 0xb0, 0x28, 0xea, 0xb3, 0xbb, 0xd1, 0x4d, 0xa2, 0x5e, 0x07, 0x65,
	0xf6, 0x67, 0x80, 0x3e, 0xca, 0x64, 0x6b, 0xd6, 0x7c, 0xd4, 0xbf, 0xf5, 0x67, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x43, 0x27, 0xc7, 0xb6, 0x2d, 0x10, 0x00, 0x00,
}

func (m *DerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaintenanceMarginRatio) > 0 {
		i -= len(m.MaintenanceMarginRatio)
		copy(dAtA[i:], m.MaintenanceMarginRatio)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MaintenanceMarginRatio)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.InitialMarginRatio) > 0 {
		i -= len(m.InitialMarginRatio)
		copy(dAtA[i:], m.InitialMarginRatio)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.InitialMarginRatio)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IndexPrice) > 0 {
		i -= len(m.IndexPrice)
		copy(dAtA[i:], m.IndexPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.IndexPrice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PriceFactor) > 0 {
		i -= len(m.PriceFactor)
		copy(dAtA[i:], m.PriceFactor)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PriceFactor)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Oracle) > 0 {
		i -= len(m.Oracle)
		copy(dAtA[i:], m.Oracle)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Oracle)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TakerFeeAssetData) > 0 {
		i -= len(m.TakerFeeAssetData)
		copy(dAtA[i:], m.TakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.MakerFeeAssetData) > 0 {
		i -= len(m.MakerFeeAssetData)
		copy(dAtA[i:], m.MakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFeeAssetData)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MakerFee) > 0 {
		i -= len(m.MakerFee)
		copy(dAtA[i:], m.MakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFee)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TakerAssetAmount) > 0 {
		i -= len(m.TakerAssetAmount)
		copy(dAtA[i:], m.TakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MakerAssetAmount) > 0 {
		i -= len(m.MakerAssetAmount)
		copy(dAtA[i:], m.MakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SenderAddress) > 0 {
		i -= len(m.SenderAddress)
		copy(dAtA[i:], m.SenderAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SenderAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TakerAddress) > 0 {
		i -= len(m.TakerAddress)
		copy(dAtA[i:], m.TakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.ChainId)<<1)^uint64((m.ChainId>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IndexPriceRequirement) > 0 {
		i -= len(m.IndexPriceRequirement)
		copy(dAtA[i:], m.IndexPriceRequirement)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.IndexPriceRequirement)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.Status)<<1)^uint64((m.Status>>63))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FilledAmount) > 0 {
		i -= len(m.FilledAmount)
		copy(dAtA[i:], m.FilledAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FilledAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderQuote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderQuote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderQuote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FillableAmount) > 0 {
		i -= len(m.FillableAmount)
		copy(dAtA[i:], m.FillableAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FillableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Q) > 0 {
		i -= len(m.Q)
		copy(dAtA[i:], m.Q)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Q)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.P) > 0 {
		i -= len(m.P)
		copy(dAtA[i:], m.P)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.P)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignerAddress) > 0 {
		i -= len(m.SignerAddress)
		copy(dAtA[i:], m.SignerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SignerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifyingContract) > 0 {
		i -= len(m.VerifyingContract)
		copy(dAtA[i:], m.VerifyingContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.VerifyingContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FillSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FillSignatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FillSignatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetFillAmount) > 0 {
		i -= len(m.TakerAssetFillAmount)
		copy(dAtA[i:], m.TakerAssetFillAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetFillAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalSignatures) > 0 {
		for iNdEx := len(m.ApprovalSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApprovalSignatures[iNdEx])
			copy(dAtA[i:], m.ApprovalSignatures[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroExTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroExTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroExTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Orders[iNdEx])
			copy(dAtA[i:], m.Orders[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.Orders[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ZeroExTransactionType != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.ZeroExTransactionType)<<1)^uint64((m.ZeroExTransactionType>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestFillSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestFillSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestFillSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalSignature) > 0 {
		i -= len(m.ApprovalSignature)
		copy(dAtA[i:], m.ApprovalSignature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SignedTransaction != nil {
		{
			size, err := m.SignedTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestSoftCancelSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestSoftCancelSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestSoftCancelSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalSignature) > 0 {
		i -= len(m.ApprovalSignature)
		copy(dAtA[i:], m.ApprovalSignature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SignedTransaction != nil {
		{
			size, err := m.SignedTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Market != nil {
		{
			size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrders(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Oracle)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PriceFactor)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.IndexPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.InitialMarginRatio)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MaintenanceMarginRatio)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *TradePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *BaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sozOrders(uint64(m.ChainId))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SenderAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFeeAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FilledAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sozOrders(uint64(m.Status))
	}
	l = len(m.IndexPriceRequirement)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *OrderQuote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FillableAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *PriceLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.P)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *SignedTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SignerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *ExchangeDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerifyingContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *FillSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if len(m.ApprovalSignatures) > 0 {
		for _, s := range m.ApprovalSignatures {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetFillAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *ZeroExTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZeroExTransactionType != 0 {
		n += 1 + sozOrders(uint64(m.ZeroExTransactionType))
	}
	if len(m.Orders) > 0 {
		for _, s := range m.Orders {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgCreateDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRequestFillSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.SignedTransaction != nil {
		l = m.SignedTransaction.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ApprovalSignature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRequestSoftCancelSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.SignedTransaction != nil {
		l = m.SignedTransaction.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ApprovalSignature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *MsgSuspendSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgSuspendDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func sovOrders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrders(x uint64) (n int) {
	return sovOrders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ChainId = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Status = int64(v)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceRequirement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPriceRequirement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderQuote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderQuote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderQuote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FillableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &ExchangeDomain{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FillSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FillSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FillSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignatures = append(m.ApprovalSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetFillAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetFillAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroExTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroExTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroExTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroExTransactionType", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ZeroExTransactionType = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestFillSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestFillSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestFillSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransaction == nil {
				m.SignedTransaction = &SignedTransaction{}
			}
			if err := m.SignedTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestSoftCancelSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestSoftCancelSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestSoftCancelSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransaction == nil {
				m.SignedTransaction = &SignedTransaction{}
			}
			if err := m.SignedTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &DerivativeMarket{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrders = fmt.Errorf("proto: unexpected end of group")
)
