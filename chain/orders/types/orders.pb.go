// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/orders/v1beta1/orders.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the orders module.
type Params struct {
	FuturesEnabled []string `protobuf:"bytes,1,rep,name=futures_enabled,json=futuresEnabled,proto3" json:"futures_enabled,omitempty" yaml:"futures_enabled,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetFuturesEnabled() []string {
	if m != nil {
		return m.FuturesEnabled
	}
	return nil
}

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Address of the oracle for the derivative contract
	Oracle string `protobuf:"bytes,2,opt,name=oracle,proto3" json:"oracle,omitempty"`
	// Address of the base currency for the derivative contract
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// Random number to faciltate uniqueness of the derivative market ID
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,7,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// price factor
	PriceFactor string `protobuf:"bytes,8,opt,name=price_factor,json=priceFactor,proto3" json:"price_factor,omitempty"`
	// index price
	IndexPrice string `protobuf:"bytes,9,opt,name=index_price,json=indexPrice,proto3" json:"index_price,omitempty"`
	// InitialMarginRatioPermyriad
	InitialMarginRatio string `protobuf:"bytes,10,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3" json:"initial_margin_ratio,omitempty"`
	// MaintenanceMarginRatioPermyriad
	MaintenanceMarginRatio string `protobuf:"bytes,11,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3" json:"maintenance_margin_ratio,omitempty"`
	// MakerTxFeePermyriad
	MakerTxFee string `protobuf:"bytes,12,opt,name=maker_tx_fee,json=makerTxFee,proto3" json:"maker_tx_fee,omitempty"`
	// TakerTxFeePermyriad
	TakerTxFee string `protobuf:"bytes,13,opt,name=taker_tx_fee,json=takerTxFee,proto3" json:"taker_tx_fee,omitempty"`
	// NextFundingTimestamp in seconds
	NextFundingTimestamp string `protobuf:"bytes,14,opt,name=next_funding_timestamp,json=nextFundingTimestamp,proto3" json:"next_funding_timestamp,omitempty"`
	// FundingInterval in seconds
	FundingInterval string `protobuf:"bytes,15,opt,name=funding_interval,json=fundingInterval,proto3" json:"funding_interval,omitempty"`
	// Cumulative Funding in seconds
	CumulativeFunding string `protobuf:"bytes,16,opt,name=cumulative_funding,json=cumulativeFunding,proto3" json:"cumulative_funding,omitempty"`
}

func (m *DerivativeMarket) Reset()         { *m = DerivativeMarket{} }
func (m *DerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarket) ProtoMessage()    {}
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{1}
}
func (m *DerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarket.Merge(m, src)
}
func (m *DerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarket proto.InternalMessageInfo

func (m *DerivativeMarket) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *DerivativeMarket) GetOracle() string {
	if m != nil {
		return m.Oracle
	}
	return ""
}

func (m *DerivativeMarket) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *DerivativeMarket) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *DerivativeMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeMarket) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DerivativeMarket) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *DerivativeMarket) GetPriceFactor() string {
	if m != nil {
		return m.PriceFactor
	}
	return ""
}

func (m *DerivativeMarket) GetIndexPrice() string {
	if m != nil {
		return m.IndexPrice
	}
	return ""
}

func (m *DerivativeMarket) GetInitialMarginRatio() string {
	if m != nil {
		return m.InitialMarginRatio
	}
	return ""
}

func (m *DerivativeMarket) GetMaintenanceMarginRatio() string {
	if m != nil {
		return m.MaintenanceMarginRatio
	}
	return ""
}

func (m *DerivativeMarket) GetMakerTxFee() string {
	if m != nil {
		return m.MakerTxFee
	}
	return ""
}

func (m *DerivativeMarket) GetTakerTxFee() string {
	if m != nil {
		return m.TakerTxFee
	}
	return ""
}

func (m *DerivativeMarket) GetNextFundingTimestamp() string {
	if m != nil {
		return m.NextFundingTimestamp
	}
	return ""
}

func (m *DerivativeMarket) GetFundingInterval() string {
	if m != nil {
		return m.FundingInterval
	}
	return ""
}

func (m *DerivativeMarket) GetCumulativeFunding() string {
	if m != nil {
		return m.CumulativeFunding
	}
	return ""
}

// An object describing trade pair of two assets.
type TradePair struct {
	// A name of the pair in format AAA/BBB, where AAA - maker's asset, BBB -
	// taker's asset.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,2,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,3,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// Hash of both asset data, to identify the trading pair in store.
	Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *TradePair) Reset()         { *m = TradePair{} }
func (m *TradePair) String() string { return proto.CompactTextString(m) }
func (*TradePair) ProtoMessage()    {}
func (*TradePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{2}
}
func (m *TradePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradePair.Merge(m, src)
}
func (m *TradePair) XXX_Size() int {
	return m.Size()
}
func (m *TradePair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradePair.DiscardUnknown(m)
}

var xxx_messageInfo_TradePair proto.InternalMessageInfo

func (m *TradePair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TradePair) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *TradePair) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *TradePair) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TradePair) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// A valid signed 0x order based on the schema.
type BaseOrder struct {
	// Specify chain ID.
	ChainId int64 `protobuf:"zigzag64,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress string `protobuf:"bytes,2,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// Address that created the order.
	MakerAddress string `protobuf:"bytes,3,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `protobuf:"bytes,4,opt,name=taker_address,json=takerAddress,proto3" json:"taker_address,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `protobuf:"bytes,5,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `protobuf:"bytes,6,opt,name=sender_address,json=senderAddress,proto3" json:"sender_address,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `protobuf:"bytes,7,opt,name=maker_asset_amount,json=makerAssetAmount,proto3" json:"maker_asset_amount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `protobuf:"bytes,8,opt,name=taker_asset_amount,json=takerAssetAmount,proto3" json:"taker_asset_amount,omitempty"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `protobuf:"bytes,9,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `protobuf:"bytes,10,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `protobuf:"bytes,11,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `protobuf:"bytes,12,opt,name=salt,proto3" json:"salt,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,13,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,14,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `protobuf:"bytes,15,opt,name=maker_fee_asset_data,json=makerFeeAssetData,proto3" json:"maker_fee_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `protobuf:"bytes,16,opt,name=taker_fee_asset_data,json=takerFeeAssetData,proto3" json:"taker_fee_asset_data,omitempty"`
	// Order signature.
	Signature string `protobuf:"bytes,17,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BaseOrder) Reset()         { *m = BaseOrder{} }
func (m *BaseOrder) String() string { return proto.CompactTextString(m) }
func (*BaseOrder) ProtoMessage()    {}
func (*BaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{3}
}
func (m *BaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseOrder.Merge(m, src)
}
func (m *BaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *BaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BaseOrder proto.InternalMessageInfo

func (m *BaseOrder) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BaseOrder) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *BaseOrder) GetTakerAddress() string {
	if m != nil {
		return m.TakerAddress
	}
	return ""
}

func (m *BaseOrder) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *BaseOrder) GetSenderAddress() string {
	if m != nil {
		return m.SenderAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetAmount() string {
	if m != nil {
		return m.MakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetAmount() string {
	if m != nil {
		return m.TakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetMakerFee() string {
	if m != nil {
		return m.MakerFee
	}
	return ""
}

func (m *BaseOrder) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *BaseOrder) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *BaseOrder) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetMakerFeeAssetData() string {
	if m != nil {
		return m.MakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerFeeAssetData() string {
	if m != nil {
		return m.TakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// A valid signed 0x order with Metadata.
type Order struct {
	Order                 *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	TradePairHash         string     `protobuf:"bytes,2,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
	FilledAmount          string     `protobuf:"bytes,3,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	Status                int64      `protobuf:"zigzag64,4,opt,name=status,proto3" json:"status,omitempty"`
	IndexPriceRequirement string     `protobuf:"bytes,5,opt,name=index_price_requirement,json=indexPriceRequirement,proto3" json:"index_price_requirement,omitempty"`
	SubaccountID          string     `protobuf:"bytes,6,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
	OrderType             uint64     `protobuf:"varint,7,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	TriggerPrice          string     `protobuf:"bytes,8,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{4}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Order) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

func (m *Order) GetFilledAmount() string {
	if m != nil {
		return m.FilledAmount
	}
	return ""
}

func (m *Order) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Order) GetIndexPriceRequirement() string {
	if m != nil {
		return m.IndexPriceRequirement
	}
	return ""
}

func (m *Order) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *Order) GetOrderType() uint64 {
	if m != nil {
		return m.OrderType
	}
	return 0
}

func (m *Order) GetTriggerPrice() string {
	if m != nil {
		return m.TriggerPrice
	}
	return ""
}

// An subaccount's margin info for a given base currency
type MarginInfo struct {
	MarginHold    string `protobuf:"bytes,1,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
	TotalDeposits string `protobuf:"bytes,2,opt,name=total_deposits,json=totalDeposits,proto3" json:"total_deposits,omitempty"`
}

func (m *MarginInfo) Reset()         { *m = MarginInfo{} }
func (m *MarginInfo) String() string { return proto.CompactTextString(m) }
func (*MarginInfo) ProtoMessage()    {}
func (*MarginInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{5}
}
func (m *MarginInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarginInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarginInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarginInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarginInfo.Merge(m, src)
}
func (m *MarginInfo) XXX_Size() int {
	return m.Size()
}
func (m *MarginInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MarginInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MarginInfo proto.InternalMessageInfo

func (m *MarginInfo) GetMarginHold() string {
	if m != nil {
		return m.MarginHold
	}
	return ""
}

func (m *MarginInfo) GetTotalDeposits() string {
	if m != nil {
		return m.TotalDeposits
	}
	return ""
}

type PositionInfo struct {
	IsLong               bool   `protobuf:"varint,1,opt,name=isLong,proto3" json:"isLong,omitempty"`
	BankruptcyPrice      string `protobuf:"bytes,2,opt,name=bankruptcy_price,json=bankruptcyPrice,proto3" json:"bankruptcy_price,omitempty"`
	Quantity             string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	PositionHoldQuantity string `protobuf:"bytes,4,opt,name=positionHoldQuantity,proto3" json:"positionHoldQuantity,omitempty"`
}

func (m *PositionInfo) Reset()         { *m = PositionInfo{} }
func (m *PositionInfo) String() string { return proto.CompactTextString(m) }
func (*PositionInfo) ProtoMessage()    {}
func (*PositionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{6}
}
func (m *PositionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionInfo.Merge(m, src)
}
func (m *PositionInfo) XXX_Size() int {
	return m.Size()
}
func (m *PositionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PositionInfo proto.InternalMessageInfo

func (m *PositionInfo) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

func (m *PositionInfo) GetBankruptcyPrice() string {
	if m != nil {
		return m.BankruptcyPrice
	}
	return ""
}

func (m *PositionInfo) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *PositionInfo) GetPositionHoldQuantity() string {
	if m != nil {
		return m.PositionHoldQuantity
	}
	return ""
}

// An order quote with fillable data
type OrderQuote struct {
	Order          *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	FillableAmount string     `protobuf:"bytes,2,opt,name=fillable_amount,json=fillableAmount,proto3" json:"fillable_amount,omitempty"`
}

func (m *OrderQuote) Reset()         { *m = OrderQuote{} }
func (m *OrderQuote) String() string { return proto.CompactTextString(m) }
func (*OrderQuote) ProtoMessage()    {}
func (*OrderQuote) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{7}
}
func (m *OrderQuote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderQuote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderQuote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderQuote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderQuote.Merge(m, src)
}
func (m *OrderQuote) XXX_Size() int {
	return m.Size()
}
func (m *OrderQuote) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderQuote.DiscardUnknown(m)
}

var xxx_messageInfo_OrderQuote proto.InternalMessageInfo

func (m *OrderQuote) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *OrderQuote) GetFillableAmount() string {
	if m != nil {
		return m.FillableAmount
	}
	return ""
}

// An orderbook price level
type PriceLevel struct {
	// price
	P string `protobuf:"bytes,1,opt,name=p,proto3" json:"p,omitempty"`
	// quantity
	Q string `protobuf:"bytes,2,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *PriceLevel) Reset()         { *m = PriceLevel{} }
func (m *PriceLevel) String() string { return proto.CompactTextString(m) }
func (*PriceLevel) ProtoMessage()    {}
func (*PriceLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{8}
}
func (m *PriceLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceLevel.Merge(m, src)
}
func (m *PriceLevel) XXX_Size() int {
	return m.Size()
}
func (m *PriceLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceLevel.DiscardUnknown(m)
}

var xxx_messageInfo_PriceLevel proto.InternalMessageInfo

func (m *PriceLevel) GetP() string {
	if m != nil {
		return m.P
	}
	return ""
}

func (m *PriceLevel) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

// A 0x Transaction Exchange Domain
type ExchangeDomain struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract string `protobuf:"bytes,1,opt,name=verifying_contract,json=verifyingContract,proto3" json:"verifying_contract,omitempty"`
	// Ethereum Chain ID of the transaction
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ExchangeDomain) Reset()         { *m = ExchangeDomain{} }
func (m *ExchangeDomain) String() string { return proto.CompactTextString(m) }
func (*ExchangeDomain) ProtoMessage()    {}
func (*ExchangeDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{9}
}
func (m *ExchangeDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDomain.Merge(m, src)
}
func (m *ExchangeDomain) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDomain.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDomain proto.InternalMessageInfo

func (m *ExchangeDomain) GetVerifyingContract() string {
	if m != nil {
		return m.VerifyingContract
	}
	return ""
}

func (m *ExchangeDomain) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// A 0x Transaction Exchange Domain
type MsgCreateSpotOrder struct {
	Sender string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgCreateSpotOrder) Reset()         { *m = MsgCreateSpotOrder{} }
func (m *MsgCreateSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotOrder) ProtoMessage()    {}
func (*MsgCreateSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{10}
}
func (m *MsgCreateSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotOrder.Merge(m, src)
}
func (m *MsgCreateSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgCreateDerivativeOrder
type MsgCreateDerivativeOrder struct {
	Sender string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgCreateDerivativeOrder) Reset()         { *m = MsgCreateDerivativeOrder{} }
func (m *MsgCreateDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{11}
}
func (m *MsgCreateDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeOrder proto.InternalMessageInfo

// A Cosmos-SDK MsgRegisterSpotMarket
type MsgRegisterSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	Enabled        bool   `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MsgRegisterSpotMarket) Reset()         { *m = MsgRegisterSpotMarket{} }
func (m *MsgRegisterSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterSpotMarket) ProtoMessage()    {}
func (*MsgRegisterSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{12}
}
func (m *MsgRegisterSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterSpotMarket.Merge(m, src)
}
func (m *MsgRegisterSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgSuspendSpotMarket
type MsgSuspendSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgSuspendSpotMarket) Reset()         { *m = MsgSuspendSpotMarket{} }
func (m *MsgSuspendSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendSpotMarket) ProtoMessage()    {}
func (*MsgSuspendSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{13}
}
func (m *MsgSuspendSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendSpotMarket.Merge(m, src)
}
func (m *MsgSuspendSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgResumeSpotMarket
type MsgResumeSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgResumeSpotMarket) Reset()         { *m = MsgResumeSpotMarket{} }
func (m *MsgResumeSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeSpotMarket) ProtoMessage()    {}
func (*MsgResumeSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{14}
}
func (m *MsgResumeSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeSpotMarket.Merge(m, src)
}
func (m *MsgResumeSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeSpotMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgRegisterDerivativeMarket
type MsgRegisterDerivativeMarket struct {
	Sender string            `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Market *DerivativeMarket `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
}

func (m *MsgRegisterDerivativeMarket) Reset()         { *m = MsgRegisterDerivativeMarket{} }
func (m *MsgRegisterDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDerivativeMarket) ProtoMessage()    {}
func (*MsgRegisterDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{15}
}
func (m *MsgRegisterDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDerivativeMarket.Merge(m, src)
}
func (m *MsgRegisterDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDerivativeMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgSuspendDerivativeMarket
type MsgSuspendDerivativeMarket struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,3,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *MsgSuspendDerivativeMarket) Reset()         { *m = MsgSuspendDerivativeMarket{} }
func (m *MsgSuspendDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendDerivativeMarket) ProtoMessage()    {}
func (*MsgSuspendDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{16}
}
func (m *MsgSuspendDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendDerivativeMarket.Merge(m, src)
}
func (m *MsgSuspendDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendDerivativeMarket proto.InternalMessageInfo

// A Cosmos-SDK MsgResumeDerivativeMarket
type MsgResumeDerivativeMarket struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// exchange address
	ExchangeAddress string `protobuf:"bytes,3,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *MsgResumeDerivativeMarket) Reset()         { *m = MsgResumeDerivativeMarket{} }
func (m *MsgResumeDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeDerivativeMarket) ProtoMessage()    {}
func (*MsgResumeDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cf94b0bf3cc7fbf1, []int{17}
}
func (m *MsgResumeDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeDerivativeMarket.Merge(m, src)
}
func (m *MsgResumeDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeDerivativeMarket proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Params)(nil), "injective.orders.v1beta1.Params")
	proto.RegisterType((*DerivativeMarket)(nil), "injective.orders.v1beta1.DerivativeMarket")
	proto.RegisterType((*TradePair)(nil), "injective.orders.v1beta1.TradePair")
	proto.RegisterType((*BaseOrder)(nil), "injective.orders.v1beta1.BaseOrder")
	proto.RegisterType((*Order)(nil), "injective.orders.v1beta1.Order")
	proto.RegisterType((*MarginInfo)(nil), "injective.orders.v1beta1.MarginInfo")
	proto.RegisterType((*PositionInfo)(nil), "injective.orders.v1beta1.PositionInfo")
	proto.RegisterType((*OrderQuote)(nil), "injective.orders.v1beta1.OrderQuote")
	proto.RegisterType((*PriceLevel)(nil), "injective.orders.v1beta1.PriceLevel")
	proto.RegisterType((*ExchangeDomain)(nil), "injective.orders.v1beta1.ExchangeDomain")
	proto.RegisterType((*MsgCreateSpotOrder)(nil), "injective.orders.v1beta1.MsgCreateSpotOrder")
	proto.RegisterType((*MsgCreateDerivativeOrder)(nil), "injective.orders.v1beta1.MsgCreateDerivativeOrder")
	proto.RegisterType((*MsgRegisterSpotMarket)(nil), "injective.orders.v1beta1.MsgRegisterSpotMarket")
	proto.RegisterType((*MsgSuspendSpotMarket)(nil), "injective.orders.v1beta1.MsgSuspendSpotMarket")
	proto.RegisterType((*MsgResumeSpotMarket)(nil), "injective.orders.v1beta1.MsgResumeSpotMarket")
	proto.RegisterType((*MsgRegisterDerivativeMarket)(nil), "injective.orders.v1beta1.MsgRegisterDerivativeMarket")
	proto.RegisterType((*MsgSuspendDerivativeMarket)(nil), "injective.orders.v1beta1.MsgSuspendDerivativeMarket")
	proto.RegisterType((*MsgResumeDerivativeMarket)(nil), "injective.orders.v1beta1.MsgResumeDerivativeMarket")
}

func init() {
	proto.RegisterFile("injective/orders/v1beta1/orders.proto", fileDescriptor_cf94b0bf3cc7fbf1)
}

var fileDescriptor_cf94b0bf3cc7fbf1 = []byte{
	// 1382 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0x1c, 0xc5,
	0x12, 0xf7, 0xd8, 0xeb, 0xcd, 0x6e, 0xd9, 0x5e, 0xdb, 0x1d, 0xdb, 0x6f, 0x92, 0xbc, 0xe7, 0xf8,
	0xad, 0x93, 0xf7, 0x0c, 0x4a, 0x6c, 0x12, 0x10, 0x82, 0xdc, 0xe2, 0x38, 0x51, 0x2c, 0xd9, 0xc2,
	0xd9, 0xf8, 0x14, 0x09, 0x8d, 0x7a, 0x67, 0x6a, 0xc7, 0x8d, 0x67, 0x7a, 0xc6, 0xdd, 0x3d, 0x96,
	0xf7, 0x84, 0xe0, 0xc4, 0x91, 0x23, 0x12, 0x1c, 0xe0, 0xce, 0x9d, 0xaf, 0x00, 0xb7, 0x1c, 0x39,
	0x21, 0x14, 0x7f, 0x03, 0x3e, 0x01, 0xea, 0x3f, 0xb3, 0xb3, 0xeb, 0x6c, 0x44, 0x10, 0x42, 0xe4,
	0x36, 0xfd, 0xab, 0x5f, 0x75, 0x57, 0x77, 0xff, 0xaa, 0xaa, 0x07, 0x6e, 0x32, 0xfe, 0x09, 0x86,
	0x8a, 0x9d, 0xe2, 0x56, 0x26, 0x22, 0x14, 0x72, 0xeb, 0xf4, 0x4e, 0x17, 0x15, 0xbd, 0xe3, 0x86,
	0x9b, 0xb9, 0xc8, 0x54, 0x46, 0xfc, 0x01, 0x6d, 0xd3, 0xe1, 0x8e, 0x76, 0x75, 0x29, 0xce, 0xe2,
	0xcc, 0x90, 0xb6, 0xf4, 0x97, 0xe5, 0xb7, 0x3f, 0x86, 0xfa, 0x01, 0x15, 0x34, 0x95, 0x64, 0x1f,
	0xe6, 0x7b, 0x85, 0x2a, 0x04, 0xca, 0x00, 0x39, 0xed, 0x26, 0x18, 0xf9, 0xde, 0xda, 0xd4, 0x46,
	0x73, 0xfb, 0xc6, 0x6f, 0xbf, 0x5c, 0x5f, 0xeb, 0xd3, 0x34, 0xb9, 0xd7, 0xbe, 0x40, 0xb8, 0x95,
	0xa5, 0x4c, 0x61, 0x9a, 0xab, 0x7e, 0xbb, 0xd3, 0x72, 0xb6, 0x87, 0xd6, 0x74, 0xaf, 0xf6, 0xd5,
	0xb7, 0xd7, 0x27, 0xda, 0xe7, 0x35, 0x58, 0xd8, 0x41, 0xc1, 0x4e, 0xa9, 0x0e, 0x69, 0x9f, 0x8a,
	0x63, 0x54, 0x64, 0x05, 0xea, 0x8a, 0x85, 0xc7, 0x28, 0x7c, 0x6f, 0xcd, 0xdb, 0x68, 0x76, 0xdc,
	0x48, 0xe3, 0x99, 0xa0, 0x61, 0x82, 0xfe, 0xa4, 0xc5, 0xed, 0x88, 0xac, 0xc3, 0x5c, 0x97, 0x4a,
	0x0c, 0xc2, 0x42, 0x08, 0xe4, 0x61, 0xdf, 0x9f, 0x32, 0xe6, 0x59, 0x0d, 0x3e, 0x70, 0x18, 0x59,
	0x82, 0x69, 0x9e, 0xf1, 0x10, 0xfd, 0x9a, 0x31, 0xda, 0x01, 0xb9, 0x06, 0xcd, 0xd4, 0x2c, 0x1a,
	0xb0, 0xc8, 0x9f, 0x36, 0x96, 0x86, 0x05, 0x76, 0x23, 0xe2, 0xc3, 0xa5, 0x72, 0xa7, 0xf5, 0x35,
	0x6f, 0xa3, 0xd1, 0x29, 0x87, 0xe4, 0x2d, 0x58, 0xc0, 0xb3, 0xf0, 0x88, 0xf2, 0x18, 0x03, 0x1a,
	0x45, 0x02, 0xa5, 0xf4, 0x2f, 0x19, 0xef, 0xf9, 0x12, 0xbf, 0x6f, 0x61, 0xf2, 0x5f, 0x98, 0xcd,
	0x05, 0x0b, 0x31, 0xe8, 0xd1, 0x50, 0x65, 0xc2, 0x6f, 0x18, 0xda, 0x8c, 0xc1, 0x1e, 0x19, 0x88,
	0x5c, 0x87, 0x19, 0xc6, 0x23, 0x3c, 0x0b, 0x0c, 0xe8, 0x37, 0x0d, 0x03, 0x0c, 0x74, 0xa0, 0x11,
	0xf2, 0x0e, 0x2c, 0x31, 0xce, 0x14, 0xa3, 0x49, 0x90, 0x52, 0x11, 0x33, 0x1e, 0x08, 0xaa, 0x58,
	0xe6, 0x83, 0x61, 0x12, 0x67, 0xdb, 0x37, 0xa6, 0x8e, 0xb6, 0x90, 0x0f, 0xc0, 0x4f, 0x29, 0xe3,
	0x0a, 0x39, 0xe5, 0x21, 0x8e, 0x7a, 0xcd, 0x18, 0xaf, 0x95, 0x21, 0xfb, 0xb0, 0xe7, 0x1a, 0xcc,
	0xa6, 0xf4, 0x18, 0x45, 0xa0, 0xce, 0x82, 0x1e, 0xa2, 0x3f, 0x6b, 0xa3, 0x31, 0xd8, 0xe1, 0xd9,
	0x23, 0x44, 0xcd, 0x50, 0xc3, 0x8c, 0x39, 0xcb, 0x50, 0x15, 0xe3, 0x3d, 0x58, 0xe1, 0x78, 0xa6,
	0x82, 0x5e, 0xc1, 0x23, 0xc6, 0xe3, 0x40, 0xb1, 0x14, 0xa5, 0xa2, 0x69, 0xee, 0xb7, 0x0c, 0x77,
	0x49, 0x5b, 0x1f, 0x59, 0xe3, 0x61, 0x69, 0xd3, 0x87, 0x5a, 0x3a, 0xe8, 0xc8, 0xc4, 0x29, 0x4d,
	0xfc, 0x79, 0x7b, 0xa8, 0x0e, 0xdf, 0x75, 0x30, 0xb9, 0x0d, 0x24, 0x2c, 0xd2, 0x22, 0x31, 0xaa,
	0x29, 0x97, 0xf1, 0x17, 0x0c, 0x79, 0xb1, 0xb2, 0xb8, 0x25, 0xda, 0xdf, 0x79, 0xd0, 0x3c, 0x14,
	0x34, 0xc2, 0x03, 0xca, 0x04, 0x21, 0x50, 0xe3, 0x34, 0x45, 0x27, 0x2e, 0xf3, 0x4d, 0x36, 0x60,
	0xc1, 0xee, 0x9a, 0x4a, 0x89, 0x2a, 0x88, 0xa8, 0xa2, 0x4e, 0x64, 0x2d, 0x83, 0xdf, 0xd7, 0xf0,
	0x0e, 0x55, 0x54, 0x33, 0xd5, 0x45, 0xa6, 0xd5, 0x5b, 0x4b, 0x8d, 0x32, 0x09, 0xd4, 0x8e, 0xa8,
	0x3c, 0x72, 0x82, 0x33, 0xdf, 0xc3, 0x92, 0x9a, 0x1e, 0x91, 0x54, 0xfb, 0xfb, 0x69, 0x68, 0x6e,
	0x53, 0x89, 0x1f, 0xe9, 0xac, 0x24, 0x57, 0xa0, 0x11, 0x1e, 0x51, 0xc6, 0xb5, 0x2c, 0x75, 0x9c,
	0xa4, 0x73, 0xc9, 0x8c, 0x77, 0xc7, 0x6b, 0x6f, 0x72, 0xbc, 0xf6, 0xd6, 0x61, 0xce, 0xed, 0xca,
	0xf1, 0x5c, 0x62, 0xd8, 0x2d, 0x55, 0x24, 0x35, 0x42, 0xb2, 0xf1, 0xda, 0x3b, 0x2e, 0x49, 0x77,
	0x61, 0xb9, 0x87, 0x18, 0x08, 0x0c, 0x59, 0xce, 0x90, 0xab, 0x01, 0xd9, 0xe6, 0xcc, 0xe5, 0x1e,
	0x62, 0xa7, 0xb4, 0x95, 0x3e, 0x37, 0xa1, 0x25, 0x91, 0x47, 0x43, 0x33, 0xd7, 0x0d, 0x79, 0xce,
	0xa2, 0x25, 0xed, 0x16, 0x90, 0xe1, 0xa3, 0xa7, 0x69, 0x56, 0x70, 0xe5, 0xb2, 0x69, 0xa1, 0x3a,
	0xfc, 0xfb, 0x06, 0xd7, 0x6c, 0xf5, 0x32, 0xdb, 0x26, 0xd5, 0x82, 0xba, 0xc8, 0x36, 0xe9, 0xad,
	0xd9, 0x5a, 0xa7, 0xcd, 0x32, 0xbd, 0x8f, 0x51, 0x68, 0x95, 0x5e, 0x83, 0xa6, 0x1a, 0x18, 0x6d,
	0x2a, 0x35, 0x54, 0x69, 0x7c, 0x1f, 0xfe, 0x85, 0x67, 0x39, 0x33, 0x19, 0xc3, 0x8d, 0x80, 0x03,
	0x89, 0x61, 0xc6, 0x23, 0xe9, 0xf2, 0x67, 0xb9, 0x32, 0x6b, 0x09, 0x3f, 0xb5, 0x46, 0x7d, 0xe9,
	0x92, 0x26, 0xca, 0xa5, 0x8d, 0xf9, 0x1e, 0x2b, 0xae, 0xb9, 0xd7, 0x16, 0x57, 0x6b, 0xac, 0xb8,
	0xb6, 0x60, 0x69, 0xb0, 0xb3, 0x61, 0xb6, 0x4d, 0x98, 0xc5, 0x72, 0x93, 0x23, 0x0e, 0x6a, 0x9c,
	0x83, 0x4b, 0x1a, 0xf5, 0x92, 0xc3, 0xbf, 0xa1, 0x29, 0x59, 0xcc, 0xa9, 0xae, 0xda, 0xfe, 0xa2,
	0x61, 0x55, 0x40, 0xfb, 0xa7, 0x49, 0x98, 0xb6, 0x52, 0xfd, 0x10, 0xa6, 0x4d, 0x27, 0x31, 0x3a,
	0x9d, 0xb9, 0xbb, 0xbe, 0xf9, 0xaa, 0x0e, 0xb3, 0x39, 0x90, 0x77, 0xc7, 0x7a, 0x90, 0xff, 0xc1,
	0xbc, 0xd2, 0x69, 0x19, 0xe4, 0x94, 0x89, 0xc0, 0x24, 0x8b, 0x55, 0xf2, 0x9c, 0x2a, 0xb3, 0xf5,
	0xb1, 0xce, 0x9a, 0x75, 0x98, 0xeb, 0xb1, 0x24, 0xc1, 0xa8, 0xbc, 0x6f, 0xa7, 0x63, 0x0b, 0xba,
	0xbb, 0x5e, 0x81, 0xba, 0x54, 0x54, 0x15, 0x56, 0xc0, 0xa4, 0xe3, 0x46, 0xfa, 0x26, 0x87, 0xaa,
	0x6b, 0x20, 0xf0, 0xa4, 0x60, 0x02, 0x53, 0xe4, 0xca, 0x89, 0x77, 0xb9, 0xaa, 0xb4, 0x9d, 0xca,
	0x48, 0x6e, 0x40, 0x4b, 0x16, 0x5d, 0x1a, 0x86, 0x7a, 0xf6, 0x80, 0x05, 0x91, 0x93, 0xef, 0x6c,
	0x85, 0xee, 0xee, 0x90, 0xff, 0x00, 0x98, 0xbd, 0x04, 0xaa, 0x9f, 0xa3, 0x51, 0x6d, 0xad, 0xd3,
	0x34, 0xc8, 0x61, 0x3f, 0x37, 0xad, 0x49, 0x09, 0x16, 0xc7, 0x28, 0x5c, 0x71, 0x6f, 0xb8, 0xe4,
	0xb2, 0xa0, 0x59, 0xb4, 0x7d, 0x08, 0x60, 0x2b, 0xf0, 0x2e, 0xef, 0x65, 0xba, 0x1b, 0xb8, 0x72,
	0x7d, 0x94, 0x25, 0x91, 0xab, 0x52, 0x60, 0xa1, 0xc7, 0x59, 0x12, 0xe9, 0xbc, 0x52, 0x99, 0xa2,
	0x49, 0x10, 0x61, 0x9e, 0x49, 0xa6, 0xe4, 0xe0, 0xd0, 0x34, 0xba, 0xe3, 0x40, 0x5d, 0xf4, 0x66,
	0x0f, 0xf4, 0x27, 0xcb, 0xec, 0xc4, 0x2b, 0x50, 0x67, 0x72, 0x2f, 0xe3, 0xb1, 0x99, 0xb3, 0xd1,
	0x71, 0x23, 0x5d, 0x50, 0xba, 0x94, 0x1f, 0x8b, 0x22, 0x57, 0x61, 0xdf, 0x85, 0xe9, 0x0a, 0x4a,
	0x85, 0xdb, 0x46, 0x74, 0x15, 0x1a, 0x27, 0x05, 0xe5, 0x8a, 0xa9, 0xb2, 0xc9, 0x0e, 0xc6, 0xe4,
	0x2e, 0x2c, 0xe5, 0x6e, 0x39, 0x1d, 0xe6, 0x93, 0x92, 0x67, 0xcb, 0xc9, 0x58, 0x5b, 0x3b, 0x07,
	0x30, 0x82, 0x78, 0x52, 0x64, 0x0a, 0xff, 0x8a, 0x92, 0xfe, 0x0f, 0xf3, 0x5a, 0x0c, 0xba, 0x94,
	0x96, 0x1a, 0x71, 0xe5, 0xbb, 0x84, 0xad, 0x4a, 0xda, 0x1b, 0x00, 0x66, 0x2b, 0x7b, 0x78, 0x8a,
	0x09, 0x99, 0x05, 0x2f, 0x77, 0x27, 0xec, 0xe5, 0x7a, 0x74, 0xe2, 0xdc, 0xbc, 0x93, 0xf6, 0x33,
	0x68, 0x3d, 0x74, 0xf5, 0x74, 0x27, 0xd3, 0xcd, 0x52, 0x77, 0x9d, 0x53, 0x14, 0xac, 0xd7, 0xd7,
	0x2d, 0x2a, 0xcc, 0xb8, 0x12, 0x34, 0x54, 0xce, 0x7d, 0x71, 0x60, 0x79, 0xe0, 0x0c, 0x23, 0x35,
	0xdc, 0xce, 0x5a, 0xd6, 0xf0, 0x76, 0x0a, 0x64, 0x5f, 0xc6, 0x0f, 0x04, 0x52, 0x85, 0x4f, 0xf3,
	0x4c, 0xd9, 0x4c, 0xd2, 0x0a, 0x36, 0xa5, 0xb1, 0x7c, 0xf7, 0xd8, 0x51, 0x75, 0x2e, 0x93, 0x7f,
	0xf6, 0x5c, 0xee, 0xd5, 0xbe, 0xd0, 0xaf, 0x2c, 0x09, 0xfe, 0x60, 0xb9, 0xea, 0xb5, 0xf5, 0x37,
	0x2f, 0xfa, 0x83, 0x07, 0xcb, 0xfb, 0x32, 0xee, 0x60, 0xcc, 0xa4, 0x42, 0xa1, 0xb7, 0x59, 0xbd,
	0xef, 0xc6, 0x2e, 0x59, 0x36, 0xe6, 0xc9, 0x3f, 0x68, 0xcc, 0x53, 0xaf, 0x5d, 0x3b, 0x6b, 0x63,
	0x6b, 0xe7, 0x2b, 0x9b, 0xb0, 0x8b, 0xfc, 0x1b, 0x0f, 0x96, 0xf6, 0x65, 0xfc, 0xb4, 0x90, 0x39,
	0xf2, 0xe8, 0xcd, 0x09, 0xdc, 0x85, 0xf7, 0xb5, 0x07, 0x97, 0xcd, 0xc1, 0xca, 0x22, 0xc5, 0x37,
	0x2e, 0xba, 0x4f, 0xe1, 0xda, 0xd0, 0xad, 0x8f, 0x7b, 0xdb, 0x8f, 0x0d, 0x72, 0x1b, 0xea, 0xf6,
	0xdd, 0xed, 0xf4, 0xf6, 0xf6, 0xab, 0xf5, 0x76, 0x71, 0xce, 0x8e, 0xf3, 0x74, 0x01, 0x7c, 0xee,
	0xc1, 0xd5, 0xea, 0xf6, 0x5e, 0x3b, 0x80, 0x91, 0x3f, 0x81, 0xc9, 0x0b, 0x7f, 0x02, 0xe3, 0xde,
	0x5c, 0x53, 0x63, 0xdf, 0x5c, 0x2e, 0x88, 0xcf, 0x3c, 0xb8, 0x32, 0xb8, 0xa3, 0x7f, 0x26, 0x86,
	0xed, 0xde, 0x8f, 0x2f, 0x56, 0xbd, 0xe7, 0x2f, 0x56, 0xbd, 0x5f, 0x5f, 0xac, 0x7a, 0x5f, 0x9e,
	0xaf, 0x4e, 0x3c, 0x3f, 0x5f, 0x9d, 0xf8, 0xf9, 0x7c, 0x75, 0xe2, 0xd9, 0x5e, 0xcc, 0xd4, 0x51,
	0xd1, 0xdd, 0x0c, 0xb3, 0x74, 0x6b, 0xb7, 0x3c, 0xe6, 0x3d, 0xda, 0x95, 0x5b, 0x83, 0x43, 0xbf,
	0x1d, 0x66, 0x02, 0x87, 0x87, 0xba, 0x72, 0x6d, 0xa5, 0x59, 0x54, 0x24, 0x28, 0xcb, 0x3f, 0x4c,
	0xdd, 0xf3, 0x64, 0xb7, 0x6e, 0xfe, 0x14, 0xdf, 0xfd, 0x3d, 0x00, 0x00, 0xff, 0xff, 0x93, 0x22,
	0xfd, 0x17, 0x82, 0x0e, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FuturesEnabled) > 0 {
		for iNdEx := len(m.FuturesEnabled) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FuturesEnabled[iNdEx])
			copy(dAtA[i:], m.FuturesEnabled[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.FuturesEnabled[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CumulativeFunding) > 0 {
		i -= len(m.CumulativeFunding)
		copy(dAtA[i:], m.CumulativeFunding)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.CumulativeFunding)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.FundingInterval) > 0 {
		i -= len(m.FundingInterval)
		copy(dAtA[i:], m.FundingInterval)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FundingInterval)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.NextFundingTimestamp) > 0 {
		i -= len(m.NextFundingTimestamp)
		copy(dAtA[i:], m.NextFundingTimestamp)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.NextFundingTimestamp)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.TakerTxFee) > 0 {
		i -= len(m.TakerTxFee)
		copy(dAtA[i:], m.TakerTxFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerTxFee)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.MakerTxFee) > 0 {
		i -= len(m.MakerTxFee)
		copy(dAtA[i:], m.MakerTxFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerTxFee)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.MaintenanceMarginRatio) > 0 {
		i -= len(m.MaintenanceMarginRatio)
		copy(dAtA[i:], m.MaintenanceMarginRatio)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MaintenanceMarginRatio)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.InitialMarginRatio) > 0 {
		i -= len(m.InitialMarginRatio)
		copy(dAtA[i:], m.InitialMarginRatio)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.InitialMarginRatio)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.IndexPrice) > 0 {
		i -= len(m.IndexPrice)
		copy(dAtA[i:], m.IndexPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.IndexPrice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PriceFactor) > 0 {
		i -= len(m.PriceFactor)
		copy(dAtA[i:], m.PriceFactor)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PriceFactor)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Oracle) > 0 {
		i -= len(m.Oracle)
		copy(dAtA[i:], m.Oracle)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Oracle)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TakerFeeAssetData) > 0 {
		i -= len(m.TakerFeeAssetData)
		copy(dAtA[i:], m.TakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.MakerFeeAssetData) > 0 {
		i -= len(m.MakerFeeAssetData)
		copy(dAtA[i:], m.MakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFeeAssetData)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MakerFee) > 0 {
		i -= len(m.MakerFee)
		copy(dAtA[i:], m.MakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFee)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TakerAssetAmount) > 0 {
		i -= len(m.TakerAssetAmount)
		copy(dAtA[i:], m.TakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MakerAssetAmount) > 0 {
		i -= len(m.MakerAssetAmount)
		copy(dAtA[i:], m.MakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SenderAddress) > 0 {
		i -= len(m.SenderAddress)
		copy(dAtA[i:], m.SenderAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SenderAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TakerAddress) > 0 {
		i -= len(m.TakerAddress)
		copy(dAtA[i:], m.TakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.ChainId)<<1)^uint64((m.ChainId>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TriggerPrice) > 0 {
		i -= len(m.TriggerPrice)
		copy(dAtA[i:], m.TriggerPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TriggerPrice)))
		i--
		dAtA[i] = 0x42
	}
	if m.OrderType != 0 {
		i = encodeVarintOrders(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IndexPriceRequirement) > 0 {
		i -= len(m.IndexPriceRequirement)
		copy(dAtA[i:], m.IndexPriceRequirement)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.IndexPriceRequirement)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.Status)<<1)^uint64((m.Status>>63))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FilledAmount) > 0 {
		i -= len(m.FilledAmount)
		copy(dAtA[i:], m.FilledAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FilledAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarginInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarginInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarginInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalDeposits) > 0 {
		i -= len(m.TotalDeposits)
		copy(dAtA[i:], m.TotalDeposits)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TotalDeposits)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarginHold) > 0 {
		i -= len(m.MarginHold)
		copy(dAtA[i:], m.MarginHold)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarginHold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PositionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PositionHoldQuantity) > 0 {
		i -= len(m.PositionHoldQuantity)
		copy(dAtA[i:], m.PositionHoldQuantity)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PositionHoldQuantity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankruptcyPrice) > 0 {
		i -= len(m.BankruptcyPrice)
		copy(dAtA[i:], m.BankruptcyPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.BankruptcyPrice)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderQuote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderQuote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderQuote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FillableAmount) > 0 {
		i -= len(m.FillableAmount)
		copy(dAtA[i:], m.FillableAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FillableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PriceLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceLevel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceLevel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Q) > 0 {
		i -= len(m.Q)
		copy(dAtA[i:], m.Q)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Q)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.P) > 0 {
		i -= len(m.P)
		copy(dAtA[i:], m.P)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.P)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifyingContract) > 0 {
		i -= len(m.VerifyingContract)
		copy(dAtA[i:], m.VerifyingContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.VerifyingContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Market != nil {
		{
			size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrders(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FuturesEnabled) > 0 {
		for _, s := range m.FuturesEnabled {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	return n
}

func (m *DerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Oracle)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PriceFactor)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.IndexPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.InitialMarginRatio)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MaintenanceMarginRatio)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerTxFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerTxFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.NextFundingTimestamp)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FundingInterval)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.CumulativeFunding)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *TradePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *BaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sozOrders(uint64(m.ChainId))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SenderAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFeeAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FilledAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sozOrders(uint64(m.Status))
	}
	l = len(m.IndexPriceRequirement)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.OrderType != 0 {
		n += 1 + sovOrders(uint64(m.OrderType))
	}
	l = len(m.TriggerPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MarginInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarginHold)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TotalDeposits)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *PositionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLong {
		n += 2
	}
	l = len(m.BankruptcyPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PositionHoldQuantity)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *OrderQuote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FillableAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *PriceLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.P)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *ExchangeDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerifyingContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgCreateSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgCreateDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *MsgSuspendSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgSuspendDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func sovOrders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrders(x uint64) (n int) {
	return sovOrders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuturesEnabled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuturesEnabled = append(m.FuturesEnabled, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceMarginRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaintenanceMarginRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerTxFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerTxFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextFundingTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextFundingTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingInterval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingInterval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFunding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeFunding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ChainId = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Status = int64(v)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPriceRequirement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPriceRequirement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarginInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginHold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginHold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDeposits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankruptcyPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankruptcyPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionHoldQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionHoldQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderQuote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderQuote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderQuote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FillableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &DerivativeMarket{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrders = fmt.Errorf("proto: unexpected end of group")
)
