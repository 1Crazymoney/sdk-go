// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: injective/orders/v1beta1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryDerivativeOrdersQuoteRequest defines the request type for
// Query/derivativeOrdersQuote RPC method.
type QueryDerivativeOrdersQuoteRequest struct {
	// The desired quantity of derivative orders to fill
	Quantity string `protobuf:"bytes,1,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The desired marketID of the derivative orders to fill
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// True if the desired direction of the derivative orders quotes you want is
	// long.
	IsLong bool `protobuf:"varint,3,opt,name=isLong,proto3" json:"isLong,omitempty"`
	// Optional maker address of trader requesting the quote (to filter out the
	// trader's own orders)
	MakerAddress string `protobuf:"bytes,4,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
}

func (m *QueryDerivativeOrdersQuoteRequest) Reset()         { *m = QueryDerivativeOrdersQuoteRequest{} }
func (m *QueryDerivativeOrdersQuoteRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrdersQuoteRequest) ProtoMessage()    {}
func (*QueryDerivativeOrdersQuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{0}
}
func (m *QueryDerivativeOrdersQuoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrdersQuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrdersQuoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrdersQuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrdersQuoteRequest.Merge(m, src)
}
func (m *QueryDerivativeOrdersQuoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrdersQuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrdersQuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrdersQuoteRequest proto.InternalMessageInfo

func (m *QueryDerivativeOrdersQuoteRequest) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *QueryDerivativeOrdersQuoteRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QueryDerivativeOrdersQuoteRequest) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

func (m *QueryDerivativeOrdersQuoteRequest) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

// QueryDerivativeOrdersQuoteResponse defines the response type for
// Query/derivativeOrdersQuote RPC method.
type QueryDerivativeOrdersQuoteResponse struct {
	// The derivative orders quotes for the taker
	Quotes []*OrderQuote `protobuf:"bytes,1,rep,name=quotes,proto3" json:"quotes,omitempty"`
}

func (m *QueryDerivativeOrdersQuoteResponse) Reset()         { *m = QueryDerivativeOrdersQuoteResponse{} }
func (m *QueryDerivativeOrdersQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrdersQuoteResponse) ProtoMessage()    {}
func (*QueryDerivativeOrdersQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{1}
}
func (m *QueryDerivativeOrdersQuoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrdersQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrdersQuoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrdersQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrdersQuoteResponse.Merge(m, src)
}
func (m *QueryDerivativeOrdersQuoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrdersQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrdersQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrdersQuoteResponse proto.InternalMessageInfo

func (m *QueryDerivativeOrdersQuoteResponse) GetQuotes() []*OrderQuote {
	if m != nil {
		return m.Quotes
	}
	return nil
}

// QuerySubaccountMarginHoldResponse defines the request type for
// Query/subaccountMarginHold RPC method.
type QuerySubaccountMarginHoldRequest struct {
	// The maker_address of the trader
	MakerAddress string `protobuf:"bytes,1,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// The subaccount nonce of the trader
	TakerFee string `protobuf:"bytes,2,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// The baseCurrency address to check
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// The subaccountID to check
	SubaccountID string `protobuf:"bytes,4,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *QuerySubaccountMarginHoldRequest) Reset()         { *m = QuerySubaccountMarginHoldRequest{} }
func (m *QuerySubaccountMarginHoldRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySubaccountMarginHoldRequest) ProtoMessage()    {}
func (*QuerySubaccountMarginHoldRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{2}
}
func (m *QuerySubaccountMarginHoldRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubaccountMarginHoldRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubaccountMarginHoldRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubaccountMarginHoldRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubaccountMarginHoldRequest.Merge(m, src)
}
func (m *QuerySubaccountMarginHoldRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubaccountMarginHoldRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubaccountMarginHoldRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubaccountMarginHoldRequest proto.InternalMessageInfo

func (m *QuerySubaccountMarginHoldRequest) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *QuerySubaccountMarginHoldRequest) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *QuerySubaccountMarginHoldRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *QuerySubaccountMarginHoldRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QuerySubaccountMarginHoldResponse defines the response type for
// Query/subaccountMarginHold RPC method.
type QuerySubaccountMarginHoldResponse struct {
	// The derivative orders quotes for the taker
	MarginHold string `protobuf:"bytes,1,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
}

func (m *QuerySubaccountMarginHoldResponse) Reset()         { *m = QuerySubaccountMarginHoldResponse{} }
func (m *QuerySubaccountMarginHoldResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySubaccountMarginHoldResponse) ProtoMessage()    {}
func (*QuerySubaccountMarginHoldResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{3}
}
func (m *QuerySubaccountMarginHoldResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubaccountMarginHoldResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubaccountMarginHoldResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubaccountMarginHoldResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubaccountMarginHoldResponse.Merge(m, src)
}
func (m *QuerySubaccountMarginHoldResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubaccountMarginHoldResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubaccountMarginHoldResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubaccountMarginHoldResponse proto.InternalMessageInfo

func (m *QuerySubaccountMarginHoldResponse) GetMarginHold() string {
	if m != nil {
		return m.MarginHold
	}
	return ""
}

// QueryDerivativeOrderbookRequest defines the request type for
// Query/derivativeOrderbook RPC method.
type QueryDerivativeOrderbookRequest struct {
	// The marketIDs of the orderbook to obtain
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *QueryDerivativeOrderbookRequest) Reset()         { *m = QueryDerivativeOrderbookRequest{} }
func (m *QueryDerivativeOrderbookRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrderbookRequest) ProtoMessage()    {}
func (*QueryDerivativeOrderbookRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{4}
}
func (m *QueryDerivativeOrderbookRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrderbookRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrderbookRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrderbookRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrderbookRequest.Merge(m, src)
}
func (m *QueryDerivativeOrderbookRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrderbookRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrderbookRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrderbookRequest proto.InternalMessageInfo

func (m *QueryDerivativeOrderbookRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

// QueryDerivativeOrderbookResponse defines the response type for
// Query/derivativeOrderbook RPC method.
type QueryDerivativeOrderbookResponse struct {
	// The shorts price levels
	Shorts []*PriceLevel `protobuf:"bytes,1,rep,name=shorts,proto3" json:"shorts,omitempty"`
	// The longs price levels
	Longs []*PriceLevel `protobuf:"bytes,2,rep,name=longs,proto3" json:"longs,omitempty"`
}

func (m *QueryDerivativeOrderbookResponse) Reset()         { *m = QueryDerivativeOrderbookResponse{} }
func (m *QueryDerivativeOrderbookResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrderbookResponse) ProtoMessage()    {}
func (*QueryDerivativeOrderbookResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{5}
}
func (m *QueryDerivativeOrderbookResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrderbookResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrderbookResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrderbookResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrderbookResponse.Merge(m, src)
}
func (m *QueryDerivativeOrderbookResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrderbookResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrderbookResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrderbookResponse proto.InternalMessageInfo

func (m *QueryDerivativeOrderbookResponse) GetShorts() []*PriceLevel {
	if m != nil {
		return m.Shorts
	}
	return nil
}

func (m *QueryDerivativeOrderbookResponse) GetLongs() []*PriceLevel {
	if m != nil {
		return m.Longs
	}
	return nil
}

// QueryMarginInfoRequest defines the request type for
// Query/marginInfo RPC method.
type QueryMarginInfoRequest struct {
	// The maker_address of the trader
	MakerAddress string `protobuf:"bytes,1,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// The subaccount nonce of the trader
	TakerFee        string `protobuf:"bytes,2,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	SubaccountID    string `protobuf:"bytes,3,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
	BaseCurrency    string `protobuf:"bytes,4,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	ExchangeAddress string `protobuf:"bytes,5,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
}

func (m *QueryMarginInfoRequest) Reset()         { *m = QueryMarginInfoRequest{} }
func (m *QueryMarginInfoRequest) String() string { return proto.CompactTextString(m) }
func (*QueryMarginInfoRequest) ProtoMessage()    {}
func (*QueryMarginInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{6}
}
func (m *QueryMarginInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMarginInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMarginInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMarginInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMarginInfoRequest.Merge(m, src)
}
func (m *QueryMarginInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryMarginInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMarginInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMarginInfoRequest proto.InternalMessageInfo

func (m *QueryMarginInfoRequest) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *QueryMarginInfoRequest) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *QueryMarginInfoRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

func (m *QueryMarginInfoRequest) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *QueryMarginInfoRequest) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

// QueryMarginInfoResponse defines the response type for
// Query/marginInfo RPC method.
type QueryMarginInfoResponse struct {
	MarginInfo *MarginInfo `protobuf:"bytes,1,opt,name=margin_info,json=marginInfo,proto3" json:"margin_info,omitempty"`
}

func (m *QueryMarginInfoResponse) Reset()         { *m = QueryMarginInfoResponse{} }
func (m *QueryMarginInfoResponse) String() string { return proto.CompactTextString(m) }
func (*QueryMarginInfoResponse) ProtoMessage()    {}
func (*QueryMarginInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{7}
}
func (m *QueryMarginInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMarginInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMarginInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMarginInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMarginInfoResponse.Merge(m, src)
}
func (m *QueryMarginInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryMarginInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMarginInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMarginInfoResponse proto.InternalMessageInfo

func (m *QueryMarginInfoResponse) GetMarginInfo() *MarginInfo {
	if m != nil {
		return m.MarginInfo
	}
	return nil
}

// QueryDerivativeMarketsRequest defines the request type for the
// Query/DerivativeMarkets RPC method
type QueryDerivativeMarketsRequest struct {
}

func (m *QueryDerivativeMarketsRequest) Reset()         { *m = QueryDerivativeMarketsRequest{} }
func (m *QueryDerivativeMarketsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeMarketsRequest) ProtoMessage()    {}
func (*QueryDerivativeMarketsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{8}
}
func (m *QueryDerivativeMarketsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeMarketsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeMarketsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeMarketsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeMarketsRequest.Merge(m, src)
}
func (m *QueryDerivativeMarketsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeMarketsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeMarketsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeMarketsRequest proto.InternalMessageInfo

// QueryDerivativeMarketsResponse defines the response type for
// Query/DerivativeMarkets RPC method.
type QueryDerivativeMarketsResponse struct {
	// Array of found derivative markets
	Markets []*DerivativeMarket `protobuf:"bytes,1,rep,name=markets,proto3" json:"markets,omitempty"`
}

func (m *QueryDerivativeMarketsResponse) Reset()         { *m = QueryDerivativeMarketsResponse{} }
func (m *QueryDerivativeMarketsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeMarketsResponse) ProtoMessage()    {}
func (*QueryDerivativeMarketsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{9}
}
func (m *QueryDerivativeMarketsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeMarketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeMarketsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeMarketsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeMarketsResponse.Merge(m, src)
}
func (m *QueryDerivativeMarketsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeMarketsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeMarketsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeMarketsResponse proto.InternalMessageInfo

func (m *QueryDerivativeMarketsResponse) GetMarkets() []*DerivativeMarket {
	if m != nil {
		return m.Markets
	}
	return nil
}

// QueryOrderRequest defines the request type for
// Query/Order RPC method.
type QueryOrderRequest struct {
	// The hash of the desired 0x order.
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// The marketID the desired 0x order.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The subaccount the desired 0x derivative order.
	SubaccountID string `protobuf:"bytes,3,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *QueryOrderRequest) Reset()         { *m = QueryOrderRequest{} }
func (m *QueryOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryOrderRequest) ProtoMessage()    {}
func (*QueryOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{10}
}
func (m *QueryOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOrderRequest.Merge(m, src)
}
func (m *QueryOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOrderRequest proto.InternalMessageInfo

func (m *QueryOrderRequest) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *QueryOrderRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QueryOrderRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QueryOrderResponse defines the response type for
// Query/Order RPC method.
type QueryOrderResponse struct {
	// Order data
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *QueryOrderResponse) Reset()         { *m = QueryOrderResponse{} }
func (m *QueryOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryOrderResponse) ProtoMessage()    {}
func (*QueryOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{11}
}
func (m *QueryOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOrderResponse.Merge(m, src)
}
func (m *QueryOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOrderResponse proto.InternalMessageInfo

func (m *QueryOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

// QueryActiveOrderRequest defines the request type for
// Query/ActiveOrder RPC method.
type QueryActiveOrderRequest struct {
	// The hash of the desired 0x order.
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// The marketID the desired 0x order.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The subaccount the desired 0x derivative order.
	SubaccountID string `protobuf:"bytes,3,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *QueryActiveOrderRequest) Reset()         { *m = QueryActiveOrderRequest{} }
func (m *QueryActiveOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryActiveOrderRequest) ProtoMessage()    {}
func (*QueryActiveOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{12}
}
func (m *QueryActiveOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryActiveOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryActiveOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryActiveOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryActiveOrderRequest.Merge(m, src)
}
func (m *QueryActiveOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryActiveOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryActiveOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryActiveOrderRequest proto.InternalMessageInfo

func (m *QueryActiveOrderRequest) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *QueryActiveOrderRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QueryActiveOrderRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QueryActiveOrderResponse defines the request type for
// Query/ActiveOrder RPC method.
type QueryActiveOrderResponse struct {
	// Order data
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *QueryActiveOrderResponse) Reset()         { *m = QueryActiveOrderResponse{} }
func (m *QueryActiveOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryActiveOrderResponse) ProtoMessage()    {}
func (*QueryActiveOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{13}
}
func (m *QueryActiveOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryActiveOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryActiveOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryActiveOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryActiveOrderResponse.Merge(m, src)
}
func (m *QueryActiveOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryActiveOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryActiveOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryActiveOrderResponse proto.InternalMessageInfo

func (m *QueryActiveOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

// QueryArchiveOrderRequest defines the request type for
// Query/ArchiveOrder RPC method.
type QueryArchiveOrderRequest struct {
	// The hash of the desired 0x order.
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// The marketID the desired 0x order.
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The subaccount the desired 0x derivative order.
	SubaccountID string `protobuf:"bytes,3,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *QueryArchiveOrderRequest) Reset()         { *m = QueryArchiveOrderRequest{} }
func (m *QueryArchiveOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryArchiveOrderRequest) ProtoMessage()    {}
func (*QueryArchiveOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{14}
}
func (m *QueryArchiveOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArchiveOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArchiveOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArchiveOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArchiveOrderRequest.Merge(m, src)
}
func (m *QueryArchiveOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryArchiveOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArchiveOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArchiveOrderRequest proto.InternalMessageInfo

func (m *QueryArchiveOrderRequest) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *QueryArchiveOrderRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QueryArchiveOrderRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QueryArchiveOrderResponse defines the request type for
// Query/ArchiveOrder RPC method.
type QueryArchiveOrderResponse struct {
	// Order data
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *QueryArchiveOrderResponse) Reset()         { *m = QueryArchiveOrderResponse{} }
func (m *QueryArchiveOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryArchiveOrderResponse) ProtoMessage()    {}
func (*QueryArchiveOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{15}
}
func (m *QueryArchiveOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryArchiveOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryArchiveOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryArchiveOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryArchiveOrderResponse.Merge(m, src)
}
func (m *QueryArchiveOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryArchiveOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryArchiveOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryArchiveOrderResponse proto.InternalMessageInfo

func (m *QueryArchiveOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type OrderFilters struct {
	// for derivatives
	ContractPriceBound string `protobuf:"bytes,1,opt,name=contract_price_bound,json=contractPriceBound,proto3" json:"contract_price_bound,omitempty"`
	MarketId           string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsLong             bool   `protobuf:"varint,3,opt,name=is_long,json=isLong,proto3" json:"is_long,omitempty"`
	// for normal orders
	NotExpired          bool   `protobuf:"varint,4,opt,name=not_expired,json=notExpired,proto3" json:"not_expired,omitempty"`
	MakerAssetAddress   string `protobuf:"bytes,5,opt,name=maker_asset_address,json=makerAssetAddress,proto3" json:"maker_asset_address,omitempty"`
	TakerAssetAddress   string `protobuf:"bytes,6,opt,name=taker_asset_address,json=takerAssetAddress,proto3" json:"taker_asset_address,omitempty"`
	ExchangeAddress     string `protobuf:"bytes,7,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	SenderAddress       string `protobuf:"bytes,8,opt,name=sender_address,json=senderAddress,proto3" json:"sender_address,omitempty"`
	MakerAssetData      string `protobuf:"bytes,9,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData      string `protobuf:"bytes,10,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	MakerAssetAmount    string `protobuf:"bytes,11,opt,name=maker_asset_amount,json=makerAssetAmount,proto3" json:"maker_asset_amount,omitempty"`
	TakerAssetAmount    string `protobuf:"bytes,12,opt,name=taker_asset_amount,json=takerAssetAmount,proto3" json:"taker_asset_amount,omitempty"`
	MakerAddress        string `protobuf:"bytes,13,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	NotMakerAddress     string `protobuf:"bytes,14,opt,name=not_maker_address,json=notMakerAddress,proto3" json:"not_maker_address,omitempty"`
	TakerAddress        string `protobuf:"bytes,15,opt,name=taker_address,json=takerAddress,proto3" json:"taker_address,omitempty"`
	TraderAddress       string `protobuf:"bytes,16,opt,name=trader_address,json=traderAddress,proto3" json:"trader_address,omitempty"`
	FeeRecipientAddress string `protobuf:"bytes,17,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// Filters orders with the specified makerFeeAssetData
	MakerFeeAssetData string `protobuf:"bytes,18,opt,name=maker_fee_asset_data,json=makerFeeAssetData,proto3" json:"maker_fee_asset_data,omitempty"`
	// Filters orders with the specified takerFeeAssetData
	TakerFeeAssetData string `protobuf:"bytes,19,opt,name=taker_fee_asset_data,json=takerFeeAssetData,proto3" json:"taker_fee_asset_data,omitempty"`
	// Filters orders with the specified subaccount nonce
	SubaccountNonce string `protobuf:"bytes,20,opt,name=subaccount_nonce,json=subaccountNonce,proto3" json:"subaccount_nonce,omitempty"`
	// Filters orders to match a direction "long" or "short"
	Direction string `protobuf:"bytes,21,opt,name=direction,proto3" json:"direction,omitempty"`
	// Filter out orders whose price is not less than or equal to the filter bound
	PriceLtOrEq string `protobuf:"bytes,22,opt,name=price_lt_or_eq,json=priceLtOrEq,proto3" json:"price_lt_or_eq,omitempty"`
	// Filter out orders whose price is not greater than or equal to the filter
	// bound
	PriceGtOrEq string `protobuf:"bytes,23,opt,name=price_gt_or_eq,json=priceGtOrEq,proto3" json:"price_gt_or_eq,omitempty"`
	// Filters orders to satisfy the indexPriceMinMarginRequirement
	IndexPrice string `protobuf:"bytes,24,opt,name=index_price,json=indexPrice,proto3" json:"index_price,omitempty"`
	// Filters orders to match the subaccountID
	SubaccountID string `protobuf:"bytes,25,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *OrderFilters) Reset()         { *m = OrderFilters{} }
func (m *OrderFilters) String() string { return proto.CompactTextString(m) }
func (*OrderFilters) ProtoMessage()    {}
func (*OrderFilters) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{16}
}
func (m *OrderFilters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFilters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFilters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFilters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFilters.Merge(m, src)
}
func (m *OrderFilters) XXX_Size() int {
	return m.Size()
}
func (m *OrderFilters) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFilters.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFilters proto.InternalMessageInfo

func (m *OrderFilters) GetContractPriceBound() string {
	if m != nil {
		return m.ContractPriceBound
	}
	return ""
}

func (m *OrderFilters) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *OrderFilters) GetIsLong() bool {
	if m != nil {
		return m.IsLong
	}
	return false
}

func (m *OrderFilters) GetNotExpired() bool {
	if m != nil {
		return m.NotExpired
	}
	return false
}

func (m *OrderFilters) GetMakerAssetAddress() string {
	if m != nil {
		return m.MakerAssetAddress
	}
	return ""
}

func (m *OrderFilters) GetTakerAssetAddress() string {
	if m != nil {
		return m.TakerAssetAddress
	}
	return ""
}

func (m *OrderFilters) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *OrderFilters) GetSenderAddress() string {
	if m != nil {
		return m.SenderAddress
	}
	return ""
}

func (m *OrderFilters) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *OrderFilters) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *OrderFilters) GetMakerAssetAmount() string {
	if m != nil {
		return m.MakerAssetAmount
	}
	return ""
}

func (m *OrderFilters) GetTakerAssetAmount() string {
	if m != nil {
		return m.TakerAssetAmount
	}
	return ""
}

func (m *OrderFilters) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *OrderFilters) GetNotMakerAddress() string {
	if m != nil {
		return m.NotMakerAddress
	}
	return ""
}

func (m *OrderFilters) GetTakerAddress() string {
	if m != nil {
		return m.TakerAddress
	}
	return ""
}

func (m *OrderFilters) GetTraderAddress() string {
	if m != nil {
		return m.TraderAddress
	}
	return ""
}

func (m *OrderFilters) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *OrderFilters) GetMakerFeeAssetData() string {
	if m != nil {
		return m.MakerFeeAssetData
	}
	return ""
}

func (m *OrderFilters) GetTakerFeeAssetData() string {
	if m != nil {
		return m.TakerFeeAssetData
	}
	return ""
}

func (m *OrderFilters) GetSubaccountNonce() string {
	if m != nil {
		return m.SubaccountNonce
	}
	return ""
}

func (m *OrderFilters) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *OrderFilters) GetPriceLtOrEq() string {
	if m != nil {
		return m.PriceLtOrEq
	}
	return ""
}

func (m *OrderFilters) GetPriceGtOrEq() string {
	if m != nil {
		return m.PriceGtOrEq
	}
	return ""
}

func (m *OrderFilters) GetIndexPrice() string {
	if m != nil {
		return m.IndexPrice
	}
	return ""
}

func (m *OrderFilters) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QueryDerivativeOrdersRequest defines the request type for
// Query/DerivativeOrdersRequest RPC method.
type QueryDerivativeOrdersRequest struct {
	Filters *OrderFilters `protobuf:"bytes,1,opt,name=filters,proto3" json:"filters,omitempty"`
	// Filter by status of the order
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Filter by collection of the order
	Collection string `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection,omitempty"`
	// Filter by trade pair hash
	TradePairHash string `protobuf:"bytes,4,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
}

func (m *QueryDerivativeOrdersRequest) Reset()         { *m = QueryDerivativeOrdersRequest{} }
func (m *QueryDerivativeOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrdersRequest) ProtoMessage()    {}
func (*QueryDerivativeOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{17}
}
func (m *QueryDerivativeOrdersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrdersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrdersRequest.Merge(m, src)
}
func (m *QueryDerivativeOrdersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrdersRequest proto.InternalMessageInfo

func (m *QueryDerivativeOrdersRequest) GetFilters() *OrderFilters {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *QueryDerivativeOrdersRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *QueryDerivativeOrdersRequest) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *QueryDerivativeOrdersRequest) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

// QuerySubaccountDerivativeOrdersRequest defines the request type for
// Query/SubaccountDerivativeOrders RPC method.
type QuerySubaccountMarketDerivativeOrdersRequest struct {
	MarketId     string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	MakerAddress string `protobuf:"bytes,2,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	TakerFee     string `protobuf:"bytes,3,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	SubaccountID string `protobuf:"bytes,4,opt,name=subaccount_i_d,json=subaccountID,proto3" json:"subaccount_i_d,omitempty"`
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) Reset() {
	*m = QuerySubaccountMarketDerivativeOrdersRequest{}
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) String() string {
	return proto.CompactTextString(m)
}
func (*QuerySubaccountMarketDerivativeOrdersRequest) ProtoMessage() {}
func (*QuerySubaccountMarketDerivativeOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{18}
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersRequest.Merge(m, src)
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersRequest proto.InternalMessageInfo

func (m *QuerySubaccountMarketDerivativeOrdersRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) GetSubaccountID() string {
	if m != nil {
		return m.SubaccountID
	}
	return ""
}

// QuerySpotOrdersRequest defines the request type for
// Query/SpotOrders RPC method.
type QuerySpotOrdersRequest struct {
	Filters *OrderFilters `protobuf:"bytes,1,opt,name=filters,proto3" json:"filters,omitempty"`
	// Filter by status of the order
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Filter by collection of the order
	Collection string `protobuf:"bytes,3,opt,name=collection,proto3" json:"collection,omitempty"`
	// Filter by trade pair hash
	TradePairHash string `protobuf:"bytes,4,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
}

func (m *QuerySpotOrdersRequest) Reset()         { *m = QuerySpotOrdersRequest{} }
func (m *QuerySpotOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySpotOrdersRequest) ProtoMessage()    {}
func (*QuerySpotOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{19}
}
func (m *QuerySpotOrdersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpotOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpotOrdersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpotOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpotOrdersRequest.Merge(m, src)
}
func (m *QuerySpotOrdersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpotOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpotOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpotOrdersRequest proto.InternalMessageInfo

func (m *QuerySpotOrdersRequest) GetFilters() *OrderFilters {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *QuerySpotOrdersRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *QuerySpotOrdersRequest) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *QuerySpotOrdersRequest) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

// QuerySpotOrdersResponse defines the request type for
// Query/SpotOrders RPC method.
type QuerySpotOrdersResponse struct {
	// An array of matched orders.
	Records []*Order `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *QuerySpotOrdersResponse) Reset()         { *m = QuerySpotOrdersResponse{} }
func (m *QuerySpotOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySpotOrdersResponse) ProtoMessage()    {}
func (*QuerySpotOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{20}
}
func (m *QuerySpotOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySpotOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySpotOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySpotOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySpotOrdersResponse.Merge(m, src)
}
func (m *QuerySpotOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySpotOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySpotOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySpotOrdersResponse proto.InternalMessageInfo

func (m *QuerySpotOrdersResponse) GetRecords() []*Order {
	if m != nil {
		return m.Records
	}
	return nil
}

// QueryTradePairRequest defines the request type for
// Query/TradePair RPC method.
type QueryTradePairRequest struct {
	// Specify name of the trade pair.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Most effective way is to specify hash of the trade pair.
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *QueryTradePairRequest) Reset()         { *m = QueryTradePairRequest{} }
func (m *QueryTradePairRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTradePairRequest) ProtoMessage()    {}
func (*QueryTradePairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{21}
}
func (m *QueryTradePairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTradePairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTradePairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTradePairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTradePairRequest.Merge(m, src)
}
func (m *QueryTradePairRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTradePairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTradePairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTradePairRequest proto.InternalMessageInfo

func (m *QueryTradePairRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryTradePairRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *QueryTradePairRequest) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *QueryTradePairRequest) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

// QueryTradePairResponse defines the request type for
// Query/TradePair RPC method.
type QueryTradePairResponse struct {
	// A name of the pair in format AAA/BBB, where AAA - maker's asset, BBB -
	// taker's asset.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,2,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,3,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// Hash of both asset data, to identify the trading pair in store.
	Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *QueryTradePairResponse) Reset()         { *m = QueryTradePairResponse{} }
func (m *QueryTradePairResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTradePairResponse) ProtoMessage()    {}
func (*QueryTradePairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{22}
}
func (m *QueryTradePairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTradePairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTradePairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTradePairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTradePairResponse.Merge(m, src)
}
func (m *QueryTradePairResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTradePairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTradePairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTradePairResponse proto.InternalMessageInfo

func (m *QueryTradePairResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryTradePairResponse) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *QueryTradePairResponse) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *QueryTradePairResponse) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *QueryTradePairResponse) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// QueryDerivativeMarketRequest defines the request type for
// Query/DerivativeMarket RPC method.
type QueryDerivativeMarketRequest struct {
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Ticker   string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
}

func (m *QueryDerivativeMarketRequest) Reset()         { *m = QueryDerivativeMarketRequest{} }
func (m *QueryDerivativeMarketRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeMarketRequest) ProtoMessage()    {}
func (*QueryDerivativeMarketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{23}
}
func (m *QueryDerivativeMarketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeMarketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeMarketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeMarketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeMarketRequest.Merge(m, src)
}
func (m *QueryDerivativeMarketRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeMarketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeMarketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeMarketRequest proto.InternalMessageInfo

func (m *QueryDerivativeMarketRequest) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *QueryDerivativeMarketRequest) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

// QueryDerivativeMarketResponse defines the request type for
// Query/DerivativeMarket RPC method.
type QueryDerivativeMarketResponse struct {
	Market *DerivativeMarket `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
}

func (m *QueryDerivativeMarketResponse) Reset()         { *m = QueryDerivativeMarketResponse{} }
func (m *QueryDerivativeMarketResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeMarketResponse) ProtoMessage()    {}
func (*QueryDerivativeMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{24}
}
func (m *QueryDerivativeMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeMarketResponse.Merge(m, src)
}
func (m *QueryDerivativeMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeMarketResponse proto.InternalMessageInfo

func (m *QueryDerivativeMarketResponse) GetMarket() *DerivativeMarket {
	if m != nil {
		return m.Market
	}
	return nil
}

// QueryTradePairsRequest defines the request type for
// Query/TradePairs RPC method.
type QueryTradePairsRequest struct {
}

func (m *QueryTradePairsRequest) Reset()         { *m = QueryTradePairsRequest{} }
func (m *QueryTradePairsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTradePairsRequest) ProtoMessage()    {}
func (*QueryTradePairsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{25}
}
func (m *QueryTradePairsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTradePairsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTradePairsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTradePairsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTradePairsRequest.Merge(m, src)
}
func (m *QueryTradePairsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTradePairsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTradePairsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTradePairsRequest proto.InternalMessageInfo

// QueryTradePairsResponse defines the response type for
// Query/TradePairs RPC method.
type QueryTradePairsResponse struct {
	// Array of found trade pairs
	Records []*TradePair `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *QueryTradePairsResponse) Reset()         { *m = QueryTradePairsResponse{} }
func (m *QueryTradePairsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTradePairsResponse) ProtoMessage()    {}
func (*QueryTradePairsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{26}
}
func (m *QueryTradePairsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTradePairsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTradePairsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTradePairsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTradePairsResponse.Merge(m, src)
}
func (m *QueryTradePairsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTradePairsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTradePairsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTradePairsResponse proto.InternalMessageInfo

func (m *QueryTradePairsResponse) GetRecords() []*TradePair {
	if m != nil {
		return m.Records
	}
	return nil
}

// QueryDerivativeOrdersResponse defines the response type for
// Query/DerivativeOrders RPC method.
type QueryDerivativeOrdersResponse struct {
	// An array of matched orders.
	Records []*Order `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *QueryDerivativeOrdersResponse) Reset()         { *m = QueryDerivativeOrdersResponse{} }
func (m *QueryDerivativeOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivativeOrdersResponse) ProtoMessage()    {}
func (*QueryDerivativeOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{27}
}
func (m *QueryDerivativeOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivativeOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivativeOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivativeOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivativeOrdersResponse.Merge(m, src)
}
func (m *QueryDerivativeOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivativeOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivativeOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivativeOrdersResponse proto.InternalMessageInfo

func (m *QueryDerivativeOrdersResponse) GetRecords() []*Order {
	if m != nil {
		return m.Records
	}
	return nil
}

// QuerySubaccountDerivativeOrdersResponse defines the response type for
// Query/SubaccountDerivativeOrders RPC method.
type QuerySubaccountMarketDerivativeOrdersResponse struct {
	// An array of matched orders.
	Records []*Order `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *QuerySubaccountMarketDerivativeOrdersResponse) Reset() {
	*m = QuerySubaccountMarketDerivativeOrdersResponse{}
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) String() string {
	return proto.CompactTextString(m)
}
func (*QuerySubaccountMarketDerivativeOrdersResponse) ProtoMessage() {}
func (*QuerySubaccountMarketDerivativeOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11505616d5f0a14, []int{28}
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersResponse.Merge(m, src)
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySubaccountMarketDerivativeOrdersResponse proto.InternalMessageInfo

func (m *QuerySubaccountMarketDerivativeOrdersResponse) GetRecords() []*Order {
	if m != nil {
		return m.Records
	}
	return nil
}

func init() {
	proto.RegisterType((*QueryDerivativeOrdersQuoteRequest)(nil), "injective.orders.v1beta1.QueryDerivativeOrdersQuoteRequest")
	proto.RegisterType((*QueryDerivativeOrdersQuoteResponse)(nil), "injective.orders.v1beta1.QueryDerivativeOrdersQuoteResponse")
	proto.RegisterType((*QuerySubaccountMarginHoldRequest)(nil), "injective.orders.v1beta1.QuerySubaccountMarginHoldRequest")
	proto.RegisterType((*QuerySubaccountMarginHoldResponse)(nil), "injective.orders.v1beta1.QuerySubaccountMarginHoldResponse")
	proto.RegisterType((*QueryDerivativeOrderbookRequest)(nil), "injective.orders.v1beta1.QueryDerivativeOrderbookRequest")
	proto.RegisterType((*QueryDerivativeOrderbookResponse)(nil), "injective.orders.v1beta1.QueryDerivativeOrderbookResponse")
	proto.RegisterType((*QueryMarginInfoRequest)(nil), "injective.orders.v1beta1.QueryMarginInfoRequest")
	proto.RegisterType((*QueryMarginInfoResponse)(nil), "injective.orders.v1beta1.QueryMarginInfoResponse")
	proto.RegisterType((*QueryDerivativeMarketsRequest)(nil), "injective.orders.v1beta1.QueryDerivativeMarketsRequest")
	proto.RegisterType((*QueryDerivativeMarketsResponse)(nil), "injective.orders.v1beta1.QueryDerivativeMarketsResponse")
	proto.RegisterType((*QueryOrderRequest)(nil), "injective.orders.v1beta1.QueryOrderRequest")
	proto.RegisterType((*QueryOrderResponse)(nil), "injective.orders.v1beta1.QueryOrderResponse")
	proto.RegisterType((*QueryActiveOrderRequest)(nil), "injective.orders.v1beta1.QueryActiveOrderRequest")
	proto.RegisterType((*QueryActiveOrderResponse)(nil), "injective.orders.v1beta1.QueryActiveOrderResponse")
	proto.RegisterType((*QueryArchiveOrderRequest)(nil), "injective.orders.v1beta1.QueryArchiveOrderRequest")
	proto.RegisterType((*QueryArchiveOrderResponse)(nil), "injective.orders.v1beta1.QueryArchiveOrderResponse")
	proto.RegisterType((*OrderFilters)(nil), "injective.orders.v1beta1.OrderFilters")
	proto.RegisterType((*QueryDerivativeOrdersRequest)(nil), "injective.orders.v1beta1.QueryDerivativeOrdersRequest")
	proto.RegisterType((*QuerySubaccountMarketDerivativeOrdersRequest)(nil), "injective.orders.v1beta1.QuerySubaccountMarketDerivativeOrdersRequest")
	proto.RegisterType((*QuerySpotOrdersRequest)(nil), "injective.orders.v1beta1.QuerySpotOrdersRequest")
	proto.RegisterType((*QuerySpotOrdersResponse)(nil), "injective.orders.v1beta1.QuerySpotOrdersResponse")
	proto.RegisterType((*QueryTradePairRequest)(nil), "injective.orders.v1beta1.QueryTradePairRequest")
	proto.RegisterType((*QueryTradePairResponse)(nil), "injective.orders.v1beta1.QueryTradePairResponse")
	proto.RegisterType((*QueryDerivativeMarketRequest)(nil), "injective.orders.v1beta1.QueryDerivativeMarketRequest")
	proto.RegisterType((*QueryDerivativeMarketResponse)(nil), "injective.orders.v1beta1.QueryDerivativeMarketResponse")
	proto.RegisterType((*QueryTradePairsRequest)(nil), "injective.orders.v1beta1.QueryTradePairsRequest")
	proto.RegisterType((*QueryTradePairsResponse)(nil), "injective.orders.v1beta1.QueryTradePairsResponse")
	proto.RegisterType((*QueryDerivativeOrdersResponse)(nil), "injective.orders.v1beta1.QueryDerivativeOrdersResponse")
	proto.RegisterType((*QuerySubaccountMarketDerivativeOrdersResponse)(nil), "injective.orders.v1beta1.QuerySubaccountMarketDerivativeOrdersResponse")
}

func init() {
	proto.RegisterFile("injective/orders/v1beta1/query.proto", fileDescriptor_d11505616d5f0a14)
}

var fileDescriptor_d11505616d5f0a14 = []byte{
	// 1759 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x6f, 0x13, 0xd7,
	0x16, 0x67, 0xf2, 0x9d, 0x93, 0xef, 0x9b, 0x10, 0x06, 0x3f, 0x70, 0xc2, 0xe4, 0x83, 0x00, 0x89,
	0x9d, 0x04, 0x01, 0x8f, 0xc0, 0x7b, 0x7a, 0xe4, 0x85, 0x40, 0xd4, 0x50, 0xc0, 0xb0, 0xa8, 0xd8,
	0xb8, 0xe3, 0x99, 0x6b, 0x7b, 0x88, 0x3d, 0xd7, 0x99, 0xb9, 0x8e, 0x88, 0xda, 0x55, 0x17, 0x5d,
	0x23, 0xb1, 0xaa, 0xd4, 0x45, 0x17, 0xad, 0xd4, 0x45, 0xd5, 0x4a, 0xad, 0xd4, 0x45, 0xd5, 0x45,
	0x97, 0x2c, 0xba, 0x88, 0xd4, 0x4d, 0x97, 0x15, 0xf4, 0xcf, 0xe8, 0xa2, 0x9a, 0xfb, 0xe1, 0x19,
	0x7b, 0xc6, 0xf6, 0x98, 0x20, 0xa4, 0xee, 0x3c, 0x67, 0x7e, 0xe7, 0x9e, 0xdf, 0x39, 0xe7, 0xde,
	0x73, 0xce, 0x5c, 0xc3, 0xbc, 0x65, 0x3f, 0xc5, 0x06, 0xb5, 0x0e, 0x70, 0x9a, 0x38, 0x26, 0x76,
	0xdc, 0xf4, 0xc1, 0x5a, 0x0e, 0x53, 0x7d, 0x2d, 0xbd, 0x5f, 0xc5, 0xce, 0x61, 0xaa, 0xe2, 0x10,
	0x4a, 0x90, 0x5a, 0x43, 0xa5, 0x38, 0x2a, 0x25, 0x50, 0x89, 0x33, 0x05, 0x42, 0x0a, 0x25, 0x9c,
	0xd6, 0x2b, 0x56, 0x5a, 0xb7, 0x6d, 0x42, 0x75, 0x6a, 0x11, 0xdb, 0xe5, 0x7a, 0x89, 0x85, 0xa6,
	0xab, 0x8b, 0x65, 0x18, 0x4c, 0xfb, 0x4c, 0x81, 0x73, 0x0f, 0x3d, 0x73, 0x5b, 0xd8, 0xb1, 0x0e,
	0x74, 0x0f, 0x7f, 0x9f, 0xbd, 0x7f, 0x58, 0x25, 0x14, 0x67, 0xf0, 0x7e, 0x15, 0xbb, 0x14, 0x25,
	0x60, 0x60, 0xbf, 0xaa, 0xdb, 0xd4, 0xa2, 0x87, 0xaa, 0x32, 0xab, 0x2c, 0x0d, 0x66, 0x6a, 0xcf,
	0xe8, 0x5f, 0x30, 0x58, 0xd6, 0x9d, 0x3d, 0x4c, 0xb3, 0x96, 0xa9, 0x76, 0xf1, 0x97, 0x5c, 0xb0,
	0x63, 0xa2, 0x69, 0xe8, 0xb3, 0xdc, 0x5d, 0x62, 0x17, 0xd4, 0xee, 0x59, 0x65, 0x69, 0x20, 0x23,
	0x9e, 0xd0, 0x1c, 0x8c, 0x94, 0xf5, 0x3d, 0xec, 0x64, 0x75, 0xd3, 0x74, 0xb0, 0xeb, 0xaa, 0x3d,
	0x4c, 0x71, 0x98, 0x09, 0x6f, 0x71, 0x99, 0x96, 0x03, 0xad, 0x15, 0x35, 0xb7, 0x42, 0x6c, 0x17,
	0xa3, 0x9b, 0xd0, 0xb7, 0xef, 0x09, 0x5c, 0x55, 0x99, 0xed, 0x5e, 0x1a, 0x5a, 0x9f, 0x4f, 0x35,
	0x8b, 0x58, 0x8a, 0xa9, 0x73, 0x6d, 0xa1, 0xa3, 0x7d, 0xa7, 0xc0, 0x2c, 0x33, 0xf2, 0xa8, 0x9a,
	0xd3, 0x0d, 0x83, 0x54, 0x6d, 0x7a, 0x4f, 0x77, 0x0a, 0x96, 0x7d, 0x97, 0x94, 0x4c, 0xe9, 0x7e,
	0x88, 0xad, 0x12, 0x66, 0xeb, 0xc5, 0x81, 0x32, 0x50, 0x1e, 0x63, 0x19, 0x07, 0x26, 0xd8, 0xc6,
	0xd8, 0x5b, 0x21, 0xa7, 0xbb, 0x38, 0x6b, 0x54, 0x1d, 0x07, 0xdb, 0xc6, 0x21, 0x0b, 0xc7, 0x60,
	0x66, 0xd8, 0x13, 0xfe, 0x5f, 0xc8, 0xd0, 0x3c, 0x8c, 0xba, 0x35, 0x16, 0x59, 0x2b, 0x6b, 0xca,
	0xa8, 0xf8, 0xd2, 0x9d, 0x2d, 0x6d, 0x4b, 0x24, 0x2c, 0x9a, 0xb0, 0x08, 0xca, 0x0c, 0x0c, 0x95,
	0x99, 0x34, 0x5b, 0x24, 0x25, 0x53, 0xf0, 0x85, 0x72, 0x0d, 0xa8, 0xfd, 0x17, 0x66, 0xa2, 0x62,
	0x9b, 0x23, 0x64, 0x4f, 0x7a, 0x5d, 0x97, 0x58, 0xa5, 0x3e, 0xb1, 0xda, 0xe7, 0x32, 0x6e, 0x91,
	0x0b, 0xf8, 0xa9, 0x71, 0x8b, 0xc4, 0xa1, 0x31, 0x52, 0xf3, 0xc0, 0xb1, 0x0c, 0xbc, 0x8b, 0x0f,
	0x70, 0x29, 0x23, 0x74, 0xd0, 0x06, 0xf4, 0x96, 0x88, 0x5d, 0x70, 0xd5, 0xae, 0x0e, 0x94, 0xb9,
	0x8a, 0x76, 0xa4, 0xc0, 0x34, 0xa3, 0xc7, 0x63, 0xb3, 0x63, 0xe7, 0xc9, 0xdb, 0x4b, 0x66, 0x38,
	0x4f, 0xdd, 0xe1, 0x3c, 0x85, 0x53, 0xde, 0x13, 0x91, 0xf2, 0x0b, 0x30, 0x8e, 0x9f, 0x19, 0x45,
	0xdd, 0x2e, 0xe0, 0x1a, 0x9f, 0x5e, 0x86, 0x1b, 0x93, 0x72, 0x79, 0x1a, 0x3e, 0x84, 0x53, 0x21,
	0x8f, 0x44, 0x9c, 0x6f, 0xd7, 0xb2, 0x6d, 0xd9, 0x79, 0xc2, 0x1c, 0x6a, 0x19, 0xaf, 0xc0, 0x12,
	0x62, 0x4f, 0x78, 0xbf, 0xb5, 0x19, 0x38, 0xdb, 0x90, 0xd2, 0x7b, 0x2c, 0xdd, 0xae, 0x08, 0x9d,
	0x96, 0x87, 0x64, 0x33, 0x80, 0x60, 0xb2, 0x05, 0xfd, 0x7c, 0x8b, 0xc8, 0x94, 0x5f, 0x6c, 0xce,
	0xa2, 0x71, 0x95, 0x8c, 0x54, 0xd5, 0xaa, 0x30, 0xc1, 0xec, 0xb0, 0x1d, 0x25, 0xf3, 0x76, 0x16,
	0x80, 0x2d, 0x90, 0x2d, 0xea, 0x6e, 0x51, 0x24, 0x6d, 0x90, 0x49, 0xee, 0xea, 0x6e, 0xb1, 0x75,
	0x19, 0x8a, 0x95, 0x31, 0xed, 0x3d, 0x40, 0x41, 0xb3, 0xc2, 0xa5, 0x2b, 0xd0, 0xcb, 0xac, 0x88,
	0xb0, 0xce, 0xb4, 0x29, 0x2f, 0x19, 0x8e, 0xd6, 0x3e, 0x12, 0xe9, 0xba, 0x65, 0xd4, 0xce, 0xc6,
	0xbb, 0xf3, 0xe4, 0x21, 0xa8, 0x61, 0xe3, 0xc7, 0xf3, 0xe7, 0x63, 0xb9, 0xa4, 0x63, 0x14, 0xdf,
	0xbd, 0x43, 0x19, 0x38, 0x1d, 0x61, 0xfd, 0x78, 0x1e, 0x7d, 0x3a, 0x00, 0xc3, 0x4c, 0xb0, 0x6d,
	0x95, 0x28, 0x76, 0x5c, 0xb4, 0x0a, 0x53, 0x06, 0xb1, 0xa9, 0xa3, 0x1b, 0x34, 0x5b, 0xf1, 0x4a,
	0x4a, 0x36, 0x47, 0xaa, 0xb6, 0xac, 0x7d, 0x48, 0xbe, 0x63, 0xd5, 0x66, 0xd3, 0x7b, 0xd3, 0xda,
	0xb3, 0x53, 0xd0, 0x6f, 0xb9, 0xd9, 0x52, 0xb8, 0xf9, 0xcd, 0xc0, 0x90, 0x4d, 0x68, 0x16, 0x3f,
	0xab, 0x58, 0x0e, 0xe6, 0x45, 0x7e, 0x20, 0x03, 0x36, 0xa1, 0xb7, 0xb9, 0x04, 0xa5, 0x60, 0x52,
	0x94, 0x28, 0xd7, 0xc5, 0xb4, 0xa1, 0x30, 0x4c, 0xf0, 0x42, 0xe5, 0xbd, 0x91, 0xd5, 0x2a, 0x05,
	0x93, 0x34, 0x02, 0xdf, 0xc7, 0xf1, 0x34, 0x84, 0x8f, 0xaa, 0x3a, 0xfd, 0x91, 0x55, 0x07, 0x2d,
	0xc0, 0xa8, 0x8b, 0x6d, 0x33, 0x50, 0x2e, 0x07, 0x18, 0x70, 0x84, 0x4b, 0x25, 0x6c, 0x09, 0xc6,
	0x83, 0x8c, 0x4d, 0x9d, 0xea, 0xea, 0x20, 0x03, 0x8e, 0xfa, 0x74, 0xb7, 0x74, 0xaa, 0x7b, 0x48,
	0xda, 0x88, 0x04, 0x8e, 0xa4, 0xf5, 0xc8, 0x65, 0x40, 0x75, 0x51, 0x28, 0x7b, 0x7b, 0x41, 0x1d,
	0x62, 0xd8, 0xf1, 0x40, 0x10, 0x98, 0xdc, 0x43, 0xd3, 0x30, 0x7a, 0x98, 0xa3, 0x69, 0x23, 0x3a,
	0xd4, 0x04, 0x46, 0x22, 0x9a, 0xc0, 0x45, 0x98, 0xf0, 0xf2, 0x54, 0x0f, 0x1c, 0xe5, 0x71, 0xb2,
	0x09, 0xbd, 0x17, 0xc4, 0xce, 0xc1, 0x08, 0xad, 0xc3, 0x8d, 0xf1, 0x05, 0x69, 0x10, 0xb4, 0x00,
	0xa3, 0xd4, 0xd1, 0x83, 0xc1, 0x1c, 0xe7, 0xc1, 0xe4, 0x52, 0x09, 0x5b, 0x87, 0x93, 0x79, 0x8c,
	0xb3, 0x0e, 0x36, 0xac, 0x8a, 0x85, 0x6d, 0x3f, 0xa1, 0x13, 0x0c, 0x3d, 0x99, 0xc7, 0x38, 0x23,
	0xdf, 0x49, 0x9d, 0x34, 0x4c, 0x95, 0x65, 0xc3, 0x0a, 0x86, 0x16, 0x05, 0xf6, 0xcc, 0x36, 0xc6,
	0x7e, 0x74, 0xd3, 0x30, 0x45, 0xa3, 0x14, 0x26, 0x03, 0x9b, 0xa6, 0x4e, 0xe1, 0x02, 0x8c, 0x07,
	0x0e, 0xaa, 0x4d, 0x6c, 0x03, 0xab, 0x53, 0x3c, 0x18, 0xbe, 0xfc, 0x7d, 0x4f, 0x8c, 0xce, 0xc0,
	0xa0, 0x69, 0x39, 0xde, 0x11, 0x24, 0xb6, 0x7a, 0x92, 0x97, 0x83, 0x9a, 0x00, 0xcd, 0xc1, 0x28,
	0x3f, 0x5d, 0x25, 0x9a, 0x25, 0x4e, 0x16, 0xef, 0xab, 0xd3, 0x0c, 0x32, 0xc4, 0xa4, 0xbb, 0xf4,
	0xbe, 0x73, 0x7b, 0xdf, 0x07, 0x15, 0x24, 0xe8, 0x54, 0x00, 0x74, 0x87, 0x83, 0x66, 0x60, 0xc8,
	0xb2, 0x4d, 0xfc, 0x8c, 0x9f, 0x56, 0x55, 0xe5, 0x53, 0x0e, 0x13, 0xb1, 0x43, 0x1a, 0x51, 0x5c,
	0x4e, 0x47, 0x14, 0x97, 0x5f, 0x14, 0x38, 0x13, 0x39, 0x68, 0xca, 0xfa, 0xf6, 0x3f, 0xe8, 0xcf,
	0xf3, 0x1a, 0x21, 0x4a, 0xcc, 0x62, 0x9b, 0x12, 0x23, 0x2a, 0x4a, 0x46, 0xaa, 0x79, 0x73, 0xb0,
	0x4b, 0x75, 0x5a, 0x75, 0x45, 0x95, 0x10, 0x4f, 0x28, 0x09, 0x60, 0x90, 0x52, 0x49, 0x84, 0x8a,
	0x57, 0xbe, 0x80, 0x04, 0x2d, 0xc2, 0x18, 0xdb, 0x1b, 0xd9, 0x8a, 0x6e, 0x89, 0xf2, 0xda, 0x13,
	0xd8, 0x32, 0x0f, 0x74, 0x8b, 0x95, 0x58, 0xed, 0x07, 0x05, 0x96, 0xc3, 0x53, 0xe1, 0x1e, 0xa6,
	0xcd, 0x5c, 0x6a, 0x35, 0xdc, 0x85, 0x4f, 0x47, 0x57, 0xbb, 0x11, 0xa9, 0xbb, 0xed, 0x88, 0x14,
	0x35, 0xca, 0xfe, 0x24, 0xa7, 0xb4, 0x47, 0x15, 0x42, 0xff, 0x69, 0x21, 0x7f, 0x2c, 0x1a, 0x7c,
	0x90, 0xbb, 0x68, 0x48, 0xd7, 0xa1, 0xdf, 0xc1, 0x06, 0x71, 0x4c, 0x39, 0x05, 0xb5, 0x6d, 0x49,
	0x12, 0xaf, 0xbd, 0x50, 0xe0, 0x24, 0x5b, 0xf6, 0xb1, 0x34, 0x26, 0x23, 0x82, 0xa0, 0xc7, 0xd6,
	0xcb, 0x58, 0x24, 0x8b, 0xfd, 0xf6, 0x64, 0x8c, 0x20, 0xf7, 0x90, 0xfd, 0x8e, 0x2c, 0xc5, 0xdd,
	0xb1, 0x4b, 0x71, 0x4f, 0x54, 0x29, 0xd6, 0xbe, 0x95, 0x89, 0x0a, 0xb0, 0x12, 0xbe, 0x46, 0xd1,
	0x8a, 0xa2, 0xd0, 0x15, 0x9b, 0x42, 0x77, 0x64, 0x37, 0x90, 0xae, 0xf6, 0x04, 0x5c, 0x55, 0xa1,
	0x1f, 0xdb, 0x7a, 0xae, 0x84, 0x4d, 0xd6, 0x1b, 0x07, 0x32, 0xf2, 0x51, 0x7b, 0x14, 0x3a, 0xd1,
	0x62, 0xc6, 0x8c, 0xb3, 0xfd, 0xa7, 0xa1, 0x8f, 0x5a, 0xc6, 0x1e, 0x76, 0xe4, 0xce, 0xe1, 0x4f,
	0x9a, 0xd1, 0x64, 0x3e, 0xae, 0xc5, 0x62, 0x13, 0xfa, 0xf8, 0x22, 0x62, 0xcf, 0x76, 0x32, 0xfc,
	0x0a, 0x4d, 0x4d, 0x6d, 0x8c, 0x74, 0x6d, 0xfa, 0xfe, 0x40, 0x6c, 0xb8, 0xe0, 0x1b, 0x61, 0xf8,
	0x3f, 0x8d, 0x1b, 0x6e, 0xae, 0xb9, 0x65, 0x3f, 0x85, 0xb5, 0x4d, 0xf7, 0x24, 0xe4, 0xd8, 0xdb,
	0xdb, 0xd0, 0x4f, 0x61, 0x25, 0x66, 0x61, 0x3a, 0xb6, 0xad, 0xf5, 0xaf, 0xa6, 0xa0, 0x97, 0x19,
	0x43, 0xcf, 0x15, 0x00, 0x7f, 0x96, 0x47, 0x97, 0x9a, 0x2f, 0x11, 0xfa, 0xd0, 0x48, 0x2c, 0xc7,
	0x03, 0x73, 0xba, 0xda, 0xf9, 0x4f, 0x7e, 0xfb, 0xf3, 0x45, 0xd7, 0x39, 0x34, 0x93, 0x6e, 0x7d,
	0xe1, 0x82, 0xbe, 0x56, 0x60, 0xbc, 0x71, 0x28, 0x47, 0x6b, 0x6d, 0x6c, 0x85, 0xbf, 0x1e, 0x12,
	0xeb, 0x9d, 0xa8, 0x08, 0x92, 0x2b, 0x8c, 0xe4, 0x79, 0xb4, 0xd0, 0x9c, 0xa4, 0x1e, 0x60, 0xf5,
	0x8d, 0x22, 0x3e, 0xc0, 0x82, 0xe3, 0x36, 0x6a, 0x6b, 0x38, 0xfc, 0x65, 0x90, 0xb8, 0xdc, 0x91,
	0x8e, 0x60, 0x9b, 0x62, 0x6c, 0x97, 0xd0, 0x62, 0x0b, 0xb6, 0x41, 0x62, 0x5f, 0x2a, 0x30, 0xd6,
	0x50, 0x8a, 0xd1, 0x6a, 0x1b, 0xc3, 0xa1, 0x8e, 0x93, 0x58, 0xeb, 0x40, 0x43, 0x10, 0x5d, 0x66,
	0x44, 0x17, 0xd1, 0x7c, 0x73, 0xa2, 0xae, 0x4f, 0xe9, 0x0b, 0x05, 0x46, 0xeb, 0x0f, 0x30, 0x4a,
	0xb7, 0xb1, 0xd9, 0xd8, 0x04, 0x12, 0xab, 0xf1, 0x15, 0x04, 0xc7, 0x4b, 0x8c, 0xe3, 0x02, 0x9a,
	0x6b, 0xce, 0xb1, 0xd6, 0xd7, 0xfc, 0x48, 0xfa, 0x35, 0x06, 0xc5, 0x36, 0x19, 0x3b, 0x92, 0xe1,
	0x02, 0x16, 0x27, 0x92, 0xd4, 0xa7, 0xf4, 0xbd, 0x6c, 0x92, 0x8d, 0x55, 0x14, 0x5d, 0x6d, 0x63,
	0xba, 0x49, 0x3f, 0x48, 0x5c, 0xeb, 0x58, 0x4f, 0x10, 0x5f, 0x62, 0xc4, 0x35, 0x34, 0xdb, 0x9c,
	0x38, 0x2f, 0xec, 0xe8, 0x47, 0xd9, 0x43, 0x43, 0xb7, 0x27, 0xa8, 0x53, 0xeb, 0xb5, 0x48, 0xff,
	0xbb, 0x73, 0x45, 0xc1, 0xfb, 0x02, 0xe3, 0x3d, 0x87, 0xce, 0xb5, 0xe3, 0xed, 0xa2, 0x9f, 0xc3,
	0xd1, 0x16, 0x3b, 0x3a, 0x7e, 0xb4, 0xeb, 0x8f, 0xda, 0xb5, 0x8e, 0xf5, 0x04, 0xeb, 0x75, 0xc6,
	0x7a, 0x19, 0x5d, 0x6c, 0xce, 0xda, 0x6c, 0x24, 0xf9, 0x97, 0x02, 0x0b, 0xb1, 0x3a, 0x10, 0xda,
	0x6e, 0x57, 0x01, 0xe2, 0xcd, 0xd6, 0x89, 0x3b, 0xc7, 0x5e, 0x47, 0xb8, 0xbb, 0xc9, 0xdc, 0xbd,
	0x89, 0x36, 0x5a, 0xd4, 0x97, 0x76, 0x4e, 0x1d, 0x29, 0x90, 0x68, 0x7e, 0x8b, 0x8e, 0x6e, 0x74,
	0x98, 0x8a, 0xe0, 0xdf, 0x02, 0x89, 0x9b, 0x6f, 0xa6, 0x2c, 0xbc, 0xbb, 0xc6, 0xbc, 0x5b, 0x43,
	0xe9, 0xf8, 0xc9, 0xe4, 0x9c, 0x7f, 0x55, 0xc4, 0x6d, 0x50, 0xd4, 0x15, 0x38, 0xda, 0xe8, 0x24,
	0xfa, 0xf5, 0x17, 0xfd, 0x89, 0x1b, 0x6f, 0xa4, 0x2b, 0xfc, 0xb9, 0xca, 0xfc, 0x59, 0x45, 0xa9,
	0x98, 0xd9, 0x92, 0x84, 0x5f, 0x2a, 0xe2, 0x6a, 0x2d, 0xe2, 0x2a, 0x1d, 0x5d, 0xef, 0x2c, 0xc4,
	0x81, 0xfb, 0xfb, 0xc4, 0xc6, 0x9b, 0xa8, 0x0a, 0x5f, 0xae, 0x30, 0x5f, 0xd2, 0x68, 0x25, 0x76,
	0x6e, 0x18, 0xdb, 0x5a, 0xff, 0xf0, 0x6f, 0x98, 0xdb, 0xf6, 0x8f, 0xd0, 0x0d, 0x7d, 0xdb, 0xfe,
	0x11, 0xbe, 0x01, 0x8f, 0xd3, 0x3f, 0xfc, 0x8b, 0xee, 0xcd, 0xfc, 0xcb, 0x57, 0x49, 0xe5, 0xe8,
	0x55, 0x52, 0xf9, 0xe3, 0x55, 0x52, 0x79, 0xfe, 0x3a, 0x79, 0xe2, 0xe8, 0x75, 0xf2, 0xc4, 0xef,
	0xaf, 0x93, 0x27, 0x9e, 0xec, 0x16, 0x2c, 0x5a, 0xac, 0xe6, 0x52, 0x06, 0x29, 0xa7, 0x77, 0xe4,
	0x4a, 0xbb, 0x7a, 0xce, 0xf5, 0xd7, 0x5d, 0x31, 0x88, 0x83, 0x83, 0x8f, 0x45, 0xdd, 0xb2, 0xd3,
	0x65, 0x62, 0x56, 0x4b, 0xd8, 0x95, 0x46, 0xe9, 0x61, 0x05, 0xbb, 0xb9, 0x3e, 0xf6, 0x1f, 0xdb,
	0xe5, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6f, 0x06, 0xd1, 0x86, 0xea, 0x1b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Retrieves an active 0x order that is associated with the hash.
	QueryOrder(ctx context.Context, in *QueryOrderRequest, opts ...grpc.CallOption) (*QueryOrderResponse, error)
	// Retrieves an active 0x order that is associated with the hash.
	QueryActiveOrder(ctx context.Context, in *QueryActiveOrderRequest, opts ...grpc.CallOption) (*QueryActiveOrderResponse, error)
	// Retrieves an archive 0x order that is associated with the hash.
	QueryArchiveOrder(ctx context.Context, in *QueryArchiveOrderRequest, opts ...grpc.CallOption) (*QueryArchiveOrderResponse, error)
	// Retrieves a list of 0x orders matching the filtering rules.
	QuerySpotOrders(ctx context.Context, in *QuerySpotOrdersRequest, opts ...grpc.CallOption) (*QuerySpotOrdersResponse, error)
	// Retrieves a trade pair by name or hash.
	QueryTradePair(ctx context.Context, in *QueryTradePairRequest, opts ...grpc.CallOption) (*QueryTradePairResponse, error)
	// Retrieves a list of trade pairs.
	QueryTradePairs(ctx context.Context, in *QueryTradePairsRequest, opts ...grpc.CallOption) (*QueryTradePairsResponse, error)
	// Retrieves a derivative market by its ID or ticker.
	QueryDerivativeMarket(ctx context.Context, in *QueryDerivativeMarketRequest, opts ...grpc.CallOption) (*QueryDerivativeMarketResponse, error)
	// Retrieves a list of derivative markets.
	QueryDerivativeMarkets(ctx context.Context, in *QueryDerivativeMarketsRequest, opts ...grpc.CallOption) (*QueryDerivativeMarketsResponse, error)
	// Retrieves a list of derivative orders matching the filtering rules.
	QueryDerivativeOrders(ctx context.Context, in *QueryDerivativeOrdersRequest, opts ...grpc.CallOption) (*QueryDerivativeOrdersResponse, error)
	// Retrieves a list of derivative orders for a provided subaccount and
	// marketID.
	QuerySubaccountMarketDerivativeOrders(ctx context.Context, in *QuerySubaccountMarketDerivativeOrdersRequest, opts ...grpc.CallOption) (*QuerySubaccountMarketDerivativeOrdersResponse, error)
	// Retrieves a list of orders matching a given market, direction and quantity
	QueryDerivativeOrdersQuote(ctx context.Context, in *QueryDerivativeOrdersQuoteRequest, opts ...grpc.CallOption) (*QueryDerivativeOrdersQuoteResponse, error)
	// Retrieves a list of orders matching a given market, direction and quantity
	QuerySubaccountMarginHold(ctx context.Context, in *QuerySubaccountMarginHoldRequest, opts ...grpc.CallOption) (*QuerySubaccountMarginHoldResponse, error)
	// Retrieves a derivative market orderbook
	QueryDerivativeOrderbook(ctx context.Context, in *QueryDerivativeOrderbookRequest, opts ...grpc.CallOption) (*QueryDerivativeOrderbookResponse, error)
	// Retrieves a subaccount's margin info for a given base currency
	QueryMarginInfo(ctx context.Context, in *QueryMarginInfoRequest, opts ...grpc.CallOption) (*QueryMarginInfoResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) QueryOrder(ctx context.Context, in *QueryOrderRequest, opts ...grpc.CallOption) (*QueryOrderResponse, error) {
	out := new(QueryOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryActiveOrder(ctx context.Context, in *QueryActiveOrderRequest, opts ...grpc.CallOption) (*QueryActiveOrderResponse, error) {
	out := new(QueryActiveOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryActiveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryArchiveOrder(ctx context.Context, in *QueryArchiveOrderRequest, opts ...grpc.CallOption) (*QueryArchiveOrderResponse, error) {
	out := new(QueryArchiveOrderResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryArchiveOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QuerySpotOrders(ctx context.Context, in *QuerySpotOrdersRequest, opts ...grpc.CallOption) (*QuerySpotOrdersResponse, error) {
	out := new(QuerySpotOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QuerySpotOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryTradePair(ctx context.Context, in *QueryTradePairRequest, opts ...grpc.CallOption) (*QueryTradePairResponse, error) {
	out := new(QueryTradePairResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryTradePair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryTradePairs(ctx context.Context, in *QueryTradePairsRequest, opts ...grpc.CallOption) (*QueryTradePairsResponse, error) {
	out := new(QueryTradePairsResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryTradePairs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryDerivativeMarket(ctx context.Context, in *QueryDerivativeMarketRequest, opts ...grpc.CallOption) (*QueryDerivativeMarketResponse, error) {
	out := new(QueryDerivativeMarketResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryDerivativeMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryDerivativeMarkets(ctx context.Context, in *QueryDerivativeMarketsRequest, opts ...grpc.CallOption) (*QueryDerivativeMarketsResponse, error) {
	out := new(QueryDerivativeMarketsResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryDerivativeMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryDerivativeOrders(ctx context.Context, in *QueryDerivativeOrdersRequest, opts ...grpc.CallOption) (*QueryDerivativeOrdersResponse, error) {
	out := new(QueryDerivativeOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryDerivativeOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QuerySubaccountMarketDerivativeOrders(ctx context.Context, in *QuerySubaccountMarketDerivativeOrdersRequest, opts ...grpc.CallOption) (*QuerySubaccountMarketDerivativeOrdersResponse, error) {
	out := new(QuerySubaccountMarketDerivativeOrdersResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QuerySubaccountMarketDerivativeOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryDerivativeOrdersQuote(ctx context.Context, in *QueryDerivativeOrdersQuoteRequest, opts ...grpc.CallOption) (*QueryDerivativeOrdersQuoteResponse, error) {
	out := new(QueryDerivativeOrdersQuoteResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryDerivativeOrdersQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QuerySubaccountMarginHold(ctx context.Context, in *QuerySubaccountMarginHoldRequest, opts ...grpc.CallOption) (*QuerySubaccountMarginHoldResponse, error) {
	out := new(QuerySubaccountMarginHoldResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QuerySubaccountMarginHold", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryDerivativeOrderbook(ctx context.Context, in *QueryDerivativeOrderbookRequest, opts ...grpc.CallOption) (*QueryDerivativeOrderbookResponse, error) {
	out := new(QueryDerivativeOrderbookResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryDerivativeOrderbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) QueryMarginInfo(ctx context.Context, in *QueryMarginInfoRequest, opts ...grpc.CallOption) (*QueryMarginInfoResponse, error) {
	out := new(QueryMarginInfoResponse)
	err := c.cc.Invoke(ctx, "/injective.orders.v1beta1.Query/QueryMarginInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Retrieves an active 0x order that is associated with the hash.
	QueryOrder(context.Context, *QueryOrderRequest) (*QueryOrderResponse, error)
	// Retrieves an active 0x order that is associated with the hash.
	QueryActiveOrder(context.Context, *QueryActiveOrderRequest) (*QueryActiveOrderResponse, error)
	// Retrieves an archive 0x order that is associated with the hash.
	QueryArchiveOrder(context.Context, *QueryArchiveOrderRequest) (*QueryArchiveOrderResponse, error)
	// Retrieves a list of 0x orders matching the filtering rules.
	QuerySpotOrders(context.Context, *QuerySpotOrdersRequest) (*QuerySpotOrdersResponse, error)
	// Retrieves a trade pair by name or hash.
	QueryTradePair(context.Context, *QueryTradePairRequest) (*QueryTradePairResponse, error)
	// Retrieves a list of trade pairs.
	QueryTradePairs(context.Context, *QueryTradePairsRequest) (*QueryTradePairsResponse, error)
	// Retrieves a derivative market by its ID or ticker.
	QueryDerivativeMarket(context.Context, *QueryDerivativeMarketRequest) (*QueryDerivativeMarketResponse, error)
	// Retrieves a list of derivative markets.
	QueryDerivativeMarkets(context.Context, *QueryDerivativeMarketsRequest) (*QueryDerivativeMarketsResponse, error)
	// Retrieves a list of derivative orders matching the filtering rules.
	QueryDerivativeOrders(context.Context, *QueryDerivativeOrdersRequest) (*QueryDerivativeOrdersResponse, error)
	// Retrieves a list of derivative orders for a provided subaccount and
	// marketID.
	QuerySubaccountMarketDerivativeOrders(context.Context, *QuerySubaccountMarketDerivativeOrdersRequest) (*QuerySubaccountMarketDerivativeOrdersResponse, error)
	// Retrieves a list of orders matching a given market, direction and quantity
	QueryDerivativeOrdersQuote(context.Context, *QueryDerivativeOrdersQuoteRequest) (*QueryDerivativeOrdersQuoteResponse, error)
	// Retrieves a list of orders matching a given market, direction and quantity
	QuerySubaccountMarginHold(context.Context, *QuerySubaccountMarginHoldRequest) (*QuerySubaccountMarginHoldResponse, error)
	// Retrieves a derivative market orderbook
	QueryDerivativeOrderbook(context.Context, *QueryDerivativeOrderbookRequest) (*QueryDerivativeOrderbookResponse, error)
	// Retrieves a subaccount's margin info for a given base currency
	QueryMarginInfo(context.Context, *QueryMarginInfoRequest) (*QueryMarginInfoResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) QueryOrder(ctx context.Context, req *QueryOrderRequest) (*QueryOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryOrder not implemented")
}
func (*UnimplementedQueryServer) QueryActiveOrder(ctx context.Context, req *QueryActiveOrderRequest) (*QueryActiveOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryActiveOrder not implemented")
}
func (*UnimplementedQueryServer) QueryArchiveOrder(ctx context.Context, req *QueryArchiveOrderRequest) (*QueryArchiveOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryArchiveOrder not implemented")
}
func (*UnimplementedQueryServer) QuerySpotOrders(ctx context.Context, req *QuerySpotOrdersRequest) (*QuerySpotOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySpotOrders not implemented")
}
func (*UnimplementedQueryServer) QueryTradePair(ctx context.Context, req *QueryTradePairRequest) (*QueryTradePairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTradePair not implemented")
}
func (*UnimplementedQueryServer) QueryTradePairs(ctx context.Context, req *QueryTradePairsRequest) (*QueryTradePairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTradePairs not implemented")
}
func (*UnimplementedQueryServer) QueryDerivativeMarket(ctx context.Context, req *QueryDerivativeMarketRequest) (*QueryDerivativeMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDerivativeMarket not implemented")
}
func (*UnimplementedQueryServer) QueryDerivativeMarkets(ctx context.Context, req *QueryDerivativeMarketsRequest) (*QueryDerivativeMarketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDerivativeMarkets not implemented")
}
func (*UnimplementedQueryServer) QueryDerivativeOrders(ctx context.Context, req *QueryDerivativeOrdersRequest) (*QueryDerivativeOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDerivativeOrders not implemented")
}
func (*UnimplementedQueryServer) QuerySubaccountMarketDerivativeOrders(ctx context.Context, req *QuerySubaccountMarketDerivativeOrdersRequest) (*QuerySubaccountMarketDerivativeOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySubaccountMarketDerivativeOrders not implemented")
}
func (*UnimplementedQueryServer) QueryDerivativeOrdersQuote(ctx context.Context, req *QueryDerivativeOrdersQuoteRequest) (*QueryDerivativeOrdersQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDerivativeOrdersQuote not implemented")
}
func (*UnimplementedQueryServer) QuerySubaccountMarginHold(ctx context.Context, req *QuerySubaccountMarginHoldRequest) (*QuerySubaccountMarginHoldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySubaccountMarginHold not implemented")
}
func (*UnimplementedQueryServer) QueryDerivativeOrderbook(ctx context.Context, req *QueryDerivativeOrderbookRequest) (*QueryDerivativeOrderbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryDerivativeOrderbook not implemented")
}
func (*UnimplementedQueryServer) QueryMarginInfo(ctx context.Context, req *QueryMarginInfoRequest) (*QueryMarginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMarginInfo not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_QueryOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryOrder(ctx, req.(*QueryOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryActiveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryActiveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryActiveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryActiveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryActiveOrder(ctx, req.(*QueryActiveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryArchiveOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryArchiveOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryArchiveOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryArchiveOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryArchiveOrder(ctx, req.(*QueryArchiveOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QuerySpotOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySpotOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QuerySpotOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QuerySpotOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QuerySpotOrders(ctx, req.(*QuerySpotOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryTradePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTradePairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryTradePair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryTradePair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryTradePair(ctx, req.(*QueryTradePairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryTradePairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTradePairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryTradePairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryTradePairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryTradePairs(ctx, req.(*QueryTradePairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryDerivativeMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivativeMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryDerivativeMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryDerivativeMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryDerivativeMarket(ctx, req.(*QueryDerivativeMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryDerivativeMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivativeMarketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryDerivativeMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryDerivativeMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryDerivativeMarkets(ctx, req.(*QueryDerivativeMarketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryDerivativeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivativeOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryDerivativeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryDerivativeOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryDerivativeOrders(ctx, req.(*QueryDerivativeOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QuerySubaccountMarketDerivativeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySubaccountMarketDerivativeOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QuerySubaccountMarketDerivativeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QuerySubaccountMarketDerivativeOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QuerySubaccountMarketDerivativeOrders(ctx, req.(*QuerySubaccountMarketDerivativeOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryDerivativeOrdersQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivativeOrdersQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryDerivativeOrdersQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryDerivativeOrdersQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryDerivativeOrdersQuote(ctx, req.(*QueryDerivativeOrdersQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QuerySubaccountMarginHold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySubaccountMarginHoldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QuerySubaccountMarginHold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QuerySubaccountMarginHold",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QuerySubaccountMarginHold(ctx, req.(*QuerySubaccountMarginHoldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryDerivativeOrderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivativeOrderbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryDerivativeOrderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryDerivativeOrderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryDerivativeOrderbook(ctx, req.(*QueryDerivativeOrderbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_QueryMarginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryMarginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).QueryMarginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/injective.orders.v1beta1.Query/QueryMarginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).QueryMarginInfo(ctx, req.(*QueryMarginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "injective.orders.v1beta1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryOrder",
			Handler:    _Query_QueryOrder_Handler,
		},
		{
			MethodName: "QueryActiveOrder",
			Handler:    _Query_QueryActiveOrder_Handler,
		},
		{
			MethodName: "QueryArchiveOrder",
			Handler:    _Query_QueryArchiveOrder_Handler,
		},
		{
			MethodName: "QuerySpotOrders",
			Handler:    _Query_QuerySpotOrders_Handler,
		},
		{
			MethodName: "QueryTradePair",
			Handler:    _Query_QueryTradePair_Handler,
		},
		{
			MethodName: "QueryTradePairs",
			Handler:    _Query_QueryTradePairs_Handler,
		},
		{
			MethodName: "QueryDerivativeMarket",
			Handler:    _Query_QueryDerivativeMarket_Handler,
		},
		{
			MethodName: "QueryDerivativeMarkets",
			Handler:    _Query_QueryDerivativeMarkets_Handler,
		},
		{
			MethodName: "QueryDerivativeOrders",
			Handler:    _Query_QueryDerivativeOrders_Handler,
		},
		{
			MethodName: "QuerySubaccountMarketDerivativeOrders",
			Handler:    _Query_QuerySubaccountMarketDerivativeOrders_Handler,
		},
		{
			MethodName: "QueryDerivativeOrdersQuote",
			Handler:    _Query_QueryDerivativeOrdersQuote_Handler,
		},
		{
			MethodName: "QuerySubaccountMarginHold",
			Handler:    _Query_QuerySubaccountMarginHold_Handler,
		},
		{
			MethodName: "QueryDerivativeOrderbook",
			Handler:    _Query_QueryDerivativeOrderbook_Handler,
		},
		{
			MethodName: "QueryMarginInfo",
			Handler:    _Query_QueryMarginInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "injective/orders/v1beta1/query.proto",
}

func (m *QueryDerivativeOrdersQuoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrdersQuoteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrdersQuoteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeOrdersQuoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrdersQuoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrdersQuoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Quotes) > 0 {
		for iNdEx := len(m.Quotes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Quotes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubaccountMarginHoldRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubaccountMarginHoldRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubaccountMarginHoldRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubaccountMarginHoldResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubaccountMarginHoldResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubaccountMarginHoldResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarginHold) > 0 {
		i -= len(m.MarginHold)
		copy(dAtA[i:], m.MarginHold)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarginHold)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeOrderbookRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrderbookRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrderbookRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeOrderbookResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrderbookResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrderbookResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Longs) > 0 {
		for iNdEx := len(m.Longs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Longs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Shorts) > 0 {
		for iNdEx := len(m.Shorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryMarginInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMarginInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMarginInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryMarginInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMarginInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryMarginInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarginInfo != nil {
		{
			size, err := m.MarginInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeMarketsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeMarketsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeMarketsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeMarketsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeMarketsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeMarketsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Markets) > 0 {
		for iNdEx := len(m.Markets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Markets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryActiveOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryActiveOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryActiveOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryActiveOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryActiveOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryActiveOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryArchiveOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArchiveOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArchiveOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryArchiveOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryArchiveOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryArchiveOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderFilters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFilters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFilters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.IndexPrice) > 0 {
		i -= len(m.IndexPrice)
		copy(dAtA[i:], m.IndexPrice)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.IndexPrice)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.PriceGtOrEq) > 0 {
		i -= len(m.PriceGtOrEq)
		copy(dAtA[i:], m.PriceGtOrEq)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PriceGtOrEq)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.PriceLtOrEq) > 0 {
		i -= len(m.PriceLtOrEq)
		copy(dAtA[i:], m.PriceLtOrEq)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PriceLtOrEq)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Direction) > 0 {
		i -= len(m.Direction)
		copy(dAtA[i:], m.Direction)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Direction)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.SubaccountNonce) > 0 {
		i -= len(m.SubaccountNonce)
		copy(dAtA[i:], m.SubaccountNonce)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountNonce)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.TakerFeeAssetData) > 0 {
		i -= len(m.TakerFeeAssetData)
		copy(dAtA[i:], m.TakerFeeAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.MakerFeeAssetData) > 0 {
		i -= len(m.MakerFeeAssetData)
		copy(dAtA[i:], m.MakerFeeAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TraderAddress) > 0 {
		i -= len(m.TraderAddress)
		copy(dAtA[i:], m.TraderAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TraderAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.TakerAddress) > 0 {
		i -= len(m.TakerAddress)
		copy(dAtA[i:], m.TakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAddress)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.NotMakerAddress) > 0 {
		i -= len(m.NotMakerAddress)
		copy(dAtA[i:], m.NotMakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.NotMakerAddress)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.TakerAssetAmount) > 0 {
		i -= len(m.TakerAssetAmount)
		copy(dAtA[i:], m.TakerAssetAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAssetAmount)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.MakerAssetAmount) > 0 {
		i -= len(m.MakerAssetAmount)
		copy(dAtA[i:], m.MakerAssetAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAssetAmount)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SenderAddress) > 0 {
		i -= len(m.SenderAddress)
		copy(dAtA[i:], m.SenderAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SenderAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TakerAssetAddress) > 0 {
		i -= len(m.TakerAssetAddress)
		copy(dAtA[i:], m.TakerAssetAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAssetAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MakerAssetAddress) > 0 {
		i -= len(m.MakerAssetAddress)
		copy(dAtA[i:], m.MakerAssetAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAssetAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NotExpired {
		i--
		if m.NotExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractPriceBound) > 0 {
		i -= len(m.ContractPriceBound)
		copy(dAtA[i:], m.ContractPriceBound)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ContractPriceBound)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrdersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.Filters != nil {
		{
			size, err := m.Filters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubaccountID) > 0 {
		i -= len(m.SubaccountID)
		copy(dAtA[i:], m.SubaccountID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SubaccountID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpotOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpotOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpotOrdersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Collection) > 0 {
		i -= len(m.Collection)
		copy(dAtA[i:], m.Collection)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Collection)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.Filters != nil {
		{
			size, err := m.Filters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySpotOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySpotOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySpotOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryTradePairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTradePairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTradePairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTradePairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTradePairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTradePairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeMarketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeMarketRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeMarketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Market != nil {
		{
			size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTradePairsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTradePairsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTradePairsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryTradePairsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTradePairsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTradePairsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivativeOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivativeOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivativeOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuerySubaccountMarketDerivativeOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySubaccountMarketDerivativeOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySubaccountMarketDerivativeOrdersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryDerivativeOrdersQuoteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsLong {
		n += 2
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeOrdersQuoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Quotes) > 0 {
		for _, e := range m.Quotes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QuerySubaccountMarginHoldRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySubaccountMarginHoldResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarginHold)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeOrderbookRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeOrderbookResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shorts) > 0 {
		for _, e := range m.Shorts {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Longs) > 0 {
		for _, e := range m.Longs {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryMarginInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryMarginInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarginInfo != nil {
		l = m.MarginInfo.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeMarketsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryDerivativeMarketsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Markets) > 0 {
		for _, e := range m.Markets {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryActiveOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryActiveOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryArchiveOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryArchiveOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *OrderFilters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractPriceBound)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IsLong {
		n += 2
	}
	if m.NotExpired {
		n += 2
	}
	l = len(m.MakerAssetAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAssetAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SenderAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.NotMakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TraderAddress)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountNonce)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.PriceLtOrEq)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.PriceGtOrEq)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.IndexPrice)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeOrdersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySubaccountMarketDerivativeOrdersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SubaccountID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySpotOrdersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Collection)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySpotOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryTradePairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryTradePairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *QueryDerivativeMarketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivativeMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryTradePairsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryTradePairsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryDerivativeOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QuerySubaccountMarketDerivativeOrdersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryDerivativeOrdersQuoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrdersQuoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrdersQuoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeOrdersQuoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrdersQuoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrdersQuoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quotes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quotes = append(m.Quotes, &OrderQuote{})
			if err := m.Quotes[len(m.Quotes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubaccountMarginHoldRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubaccountMarginHoldRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubaccountMarginHoldRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubaccountMarginHoldResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubaccountMarginHoldResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubaccountMarginHoldResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginHold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarginHold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeOrderbookRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrderbookRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrderbookRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeOrderbookResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrderbookResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrderbookResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shorts = append(m.Shorts, &PriceLevel{})
			if err := m.Shorts[len(m.Shorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Longs = append(m.Longs, &PriceLevel{})
			if err := m.Longs[len(m.Longs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMarginInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMarginInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMarginInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMarginInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMarginInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMarginInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarginInfo == nil {
				m.MarginInfo = &MarginInfo{}
			}
			if err := m.MarginInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeMarketsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeMarketsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeMarketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeMarketsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeMarketsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeMarketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markets = append(m.Markets, &DerivativeMarket{})
			if err := m.Markets[len(m.Markets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryActiveOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryActiveOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryActiveOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryActiveOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryActiveOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryActiveOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArchiveOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArchiveOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArchiveOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryArchiveOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryArchiveOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryArchiveOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFilters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFilters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFilters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractPriceBound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractPriceBound = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotExpired = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotMakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotMakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountNonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountNonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceLtOrEq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceLtOrEq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceGtOrEq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceGtOrEq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &OrderFilters{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubaccountMarketDerivativeOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubaccountMarketDerivativeOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubaccountMarketDerivativeOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubaccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpotOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpotOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpotOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &OrderFilters{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySpotOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySpotOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySpotOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &Order{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTradePairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTradePairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTradePairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTradePairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTradePairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTradePairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeMarketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeMarketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeMarketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &DerivativeMarket{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTradePairsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTradePairsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTradePairsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTradePairsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTradePairsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTradePairsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &TradePair{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivativeOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivativeOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivativeOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &Order{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySubaccountMarketDerivativeOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySubaccountMarketDerivativeOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySubaccountMarketDerivativeOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &Order{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
